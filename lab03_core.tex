\section{Εισαγωγή}
Στο εργαστήριο αυτό παρουσιάζονται ορισμένοι αλγόριθμοι ταξινόμησης και ορισμένοι αλγόριθμοι αναζήτησης. Πρόκειται για μερικούς από τους σημαντικότερους αλγορίθμους στην επιστήμη των υπολογιστών. Σε πρακτικό επίπεδο ένα σημαντικό ποσοστό της επεξεργαστικής ισχύος των υπολογιστών δαπανάται στην ταξινόμηση δεδομένων η οποία διευκολύνει τις αναζητήσεις που ακολουθούν. Επιπλέον, γίνεται αναφορά στη θεωρητική εκτίμηση της απόδοσης ενός αλγορίθμου και στη μέτρηση χρόνου εκτέλεσης κώδικα.

\section{Θεωρητική και εμπειρική εκτίμηση της απόδοσης αλγορίθμων}
Συχνά χρειάζεται να εκτιμηθεί η καταλληλότητα ενός αλγορίθμου για την επίλυση ενός προβλήματος. Ποιοτικά χαρακτηριστικά όπως ο χρόνος εκτέλεσης και ο χώρος που απαιτεί στη μνήμη και στο δίσκο μπορεί να τον καθιστούν υποδεέστερο άλλων αλγορίθμων ή ακόμα και ακατάλληλο για επίλυση του προβλήματος. Γενικά, η απόδοση ενός αλγορίθμου μπορεί να εκτιμηθεί θεωρητικά και εμπειρικά. 
\subsection{Θεωρητική μελέτη αλγορίθμων}
Η θεωρητική μελέτη προσδιορίζει την ασυμπτωτική συμπεριφορά του αλγορίθμου, δηλαδή πως θα συμπεριφέρεται ο αλγόριθμος καθώς τα δεδομένα εισόδου αυξάνονται σε μέγεθος προσεγγίζοντας μεγάλες τιμές. Μελετώντας θεωρητικά διαφορετικούς αλγορίθμους που επιτελούν το ίδιο έργο μπορεί να πραγματοποιηθεί σύγκριση μεταξύ τους ακόμα και χωρίς να γραφεί κώδικας που να τους υλοποιεί σε μια συγκεκριμένη γλώσσα προγραμματισμού. Η μέθοδος που έχει επικρατήσει για τη θεωρητική μελέτη αλγορίθμων είναι η ασυμπτωτική ανάλυση και ιδιαίτερα ο συμβολισμός του μεγάλου Ο (Big O notation). Ο συμβολισμός του μεγάλου Ο περιγράφει τη χειρότερη περίπτωση εκτέλεσης και συνήθως αφορά το χρόνο εκτέλεσης ή σπανιότερα το χώρο που απαιτείται από τον αλγόριθμο. Στη συνέχεια θα επιχειρηθεί μια πρακτική παρουσίαση του εν λόγω συμβολισμού μέσω παραδειγμάτων \cite{robbell}.
\subsubsection{$O(1)$}
Ο συμβολισμός $O(1)$ περιγράφει αλγορίθμους που πάντα εκτελούνται απαιτώντας τον ίδιο χρόνο (ή χώρο), άσχετα με το μέγεθος των δεδομένων με τα οποία τροφοδοτούνται. Ο ακόλουθος κώδικας που είναι ένα παράδειγμα αλγορίθμου με ασυμπτωτική πολυπλοκότητα $O(1)$ επιστρέφει true αν το πρώτο στοιχείο ενός πίνακα ακεραίων είναι άρτιο, αλλιώς επιστρέφει false.
\begin{lstlisting}
bool is_first_element_even(int a[]) { 
	return a[0] % 2 == 0; 
}
\end{lstlisting}

\subsubsection{$O(n)$}
Ο συμβολισμός $O(n)$ περιγράφει αλγορίθμους που ο χρόνος εκτέλεσής τους  μεγαλώνει γραμμικά και σε ευθεία αναλογία με το μέγεθος της εισόδου. Ο κώδικας που ακολουθεί επιστρέφει true αν το στοιχείο key υπάρχει στον πίνακα a, Ν θέσεων. Η ασυμπτωτική του πολυπλοκότητα είναι $O(n)$.
\begin{lstlisting}
bool exists(int a[], int N, int key) {
  for (int i = 0; i < N; i++)
    if (a[i] == key)
      return true;
  return false;
}
\end{lstlisting}

\subsubsection{$O(n^2)$}
Ο συμβολισμός $O(n^2)$ περιγράφει αλγορίθμους που ο χρόνος εκτέλεσής τους  μεγαλώνει ανάλογα με το τετράγωνο του μεγέθους της εισόδου. Αυτό τυπικά συμβαίνει όταν ο κώδικας περιέχει δύο εντολές επανάληψης την μια μέσα στην άλλη. Ο ακόλουθος κώδικας εξετάζει αν ένας πίνακας έχει διπλότυπα και έχει ασυμπτωτική πολυπλοκότητα $O(n^2)$. 
\begin{lstlisting}
bool has_duplicates(int a[], int N) {
  for (int i = 0; i < N; i++)
    for (int j = 0; j < N; j++) {
      if (i == j)
        continue;
      if (a[i] == a[j])
        return true;
    }
  return false;
}
\end{lstlisting}

\subsubsection{$O(2^n)$}
Το $O(2^n)$ αφορά αλγορίθμους που ο χρόνος εκτέλεσής τους διπλασιάζεται για κάθε μονάδα αύξησης των δεδομένων εισόδου. Η αύξηση είναι εξαιρετικά απότομη καθιστώντας τον αλγόριθμο μη χρησιμοποιήσιμο παρά μόνο για μικρές τιμές του n. Ένα παράδειγμα αλγορίθμου με ασυμπτωτική πολυπλοκότητα $O(2^n)$ είναι ο αναδρομικός υπολογισμός των αριθμών Fibonacci. Η ακολουθία Fibonacci είναι η ακόλουθη: 0, 1, 1, 2, 3, 5, 8, 13, 21, 34, 55, 89, ... Εξ ορισμού οι δύο πρώτοι όροι είναι το μηδέν και το ένα, ενώ κάθε επόμενος όρος είναι το άθροισμα των δύο προηγούμενων του. 

\begin{lstlisting}
int fibo(int n) {
  if (n <= 1)
    return n;
  else
    return fibo(n - 2) + fibo(n - 1);
}
\end{lstlisting}

\subsubsection{$O(log(n))$}
To $O(log(n))$ περιγράφει αλγορίθμους στους οποίους σε κάθε βήμα τους το μέγεθος των δεδομένων που μένει να εξετάσει ο αλγόριθμος μειώνεται στο μισό. Ένα παράδειγμα αλγορίθμου με ασυμπτωτική πολυπλοκότητα $O(log(n))$ είναι ο ακόλουθος κώδικας που επιστρέφει λογική τιμή σχετικά με το εάν υπάρχει το στοιχείο key στον ταξινομημένο πίνακα a, N θέσεων.
\begin{lstlisting}
bool exists_in_sorted(int a[], int N, int key) {
  int left = 0, right = N - 1, m;
  while (left <= right) {
    m = (left + right) / 2;
    if (a[m] == key)
      return true;
    else if (a[m] > key)
      right = m - 1;
    else
      left = m + 1;
  }
  return false;
}
\end{lstlisting}

Στη συνέχεια παρατίθενται ασυμπτωτικές πολυπλοκότητες αλγορίθμων από τις ταχύτερες προς τις βραδύτερες: $O(1)$, $O(log(n))$, $O(n)$,$O(nlog(n))$, $O(n^2)$, $O(n^3)$, $O(n^4)$, $O(2^n)$, $O(n!)$. Με εξαιρέσεις, επιθυμητές πολυπλοκότητες αλγορίθμων είναι μέχρι και $O(n^2)$.

\subsection{Εμπειρική μελέτη αλγορίθμων}
H εμπειρική εκτίμηση της απόδοσης ενός προγράμματος έχει να κάνει με τη χρονομέτρησή του για διάφορες περιπτώσεις δεδομένων εισόδου και τη σύγκρισή του με εναλλακτικές υλοποιήσεις προγραμμάτων. Στη συνέχεια θα παρουσιαστούν δύο τρόποι μέτρησης χρόνου εκτέλεσης κώδικα που μπορούν να εφαρμοστούν στη C++.

\subsubsection{Μέτρηση χρόνου εκτέλεσης κώδικα με τη συνάρτηση clock()}
Ο ακόλουθος κώδικας μετράει το χρόνο που απαιτεί ο υπολογισμός του αθροίσματος των τετραγωνικών ριζών 10.000.000 τυχαίων ακέραιων αριθμών με τιμές στο διάστημα από 0  έως 10.000. Η μέτρηση του χρόνου πραγματοποιείται με τη συνάρτηση clock() η οποία επιστρέφει τον αριθμό από clock ticks που έχουν περάσει από τη στιγμή που το πρόγραμμα ξεκίνησε την εκτέλεση του. Ο αριθμός των δευτερολέπτων που έχουν περάσει προκύπτει διαιρώντας τον αριθμό των clock ticks με τη σταθερά CLOCKS\_PER\_SEC. Αυτός ο τρόπος υπολογισμού του χρόνου εκτέλεσης έχει ``κληρονομηθεί'' στη C++ από τη C.

\lstinputlisting[caption = Μέτρηση χρόνου εκτέλεσης κώδικα(timing1.cpp)]{lab03/timing1.cpp}

\lstinputlisting[style=DOS]{lab03/timing1.out}

\subsubsection{Μέτρηση χρόνου εκτέλεσης κώδικα με τη χρήση του high\_resolution\_clock::time\_point}
Η C++ έχει προσθέσει νέους τρόπους μέτρησης του χρόνου εκτέλεσης προγραμμάτων. Στον ακόλουθο κώδικα παρουσιάζεται ένα παράδειγμα με χρήση time\_points.

\lstinputlisting[caption = Μέτρηση χρόνου εκτέλεσης κώδικα (timing2.cpp)]{lab03/timing2.cpp}

\lstinputlisting[style=DOS]{lab03/timing2.out}

Θα πρέπει να σημειωθεί ότι κατά τη μεταγλώττιση είναι δυνατό να δοθεί οδηγία προς το μεταγλωττιστή έτσι ώστε να προχωρήσει σε βελτιστοποιήσεις του κώδικα που παράγει που θα οδηγήσουν σε ταχύτερη εκτέλεση. Το flag που χρησιμοποιείται είναι το -Ο και οι πιθανές τιμές που μπορεί να λάβει είναι: -Ο0, -Ο1, -Ο2, -Ο3. Καθώς αυξάνεται ο αριθμός δεξιά του -Ο που χρησιμοποιείται στη μεταγλώττιση ενεργοποιούνται περισσότερες βελτιστοποιήσεις σε βάρος του χρόνου μεταγλώττισης. Στη συνέχεια παρουσιάζονται οι εντολές μεταγλώττισης και ο χρόνος εκτέλεσης για κάθε μια από τις 4 περιπτώσεις του κώδικα .

\lstinputlisting[style=DOS]{lab03/timing2_optimized.out}


\section{Αλγόριθμοι ταξινόμησης}
\subsection{Ταξινόμηση με εισαγωγή}
Η ταξινόμηση με εισαγωγή (\href{http://rosettacode.org/wiki/Sorting_algorithms/Insertion_sort}{insertion-sort}) λειτουργεί δημιουργώντας μια ταξινομημένη λίστα στο αριστερό άκρο των δεδομένων και επαναληπτικά τοποθετεί το στοιχείο το οποίο βρίσκεται δεξιά της ταξινομημένης λίστας στη σωστή θέση σε σχέση με τα ήδη ταξινομημένα στοιχεία. Ο αλγόριθμος ταξινόμησης με εισαγωγή καθώς και η κλήση του από κύριο πρόγραμμα για την αύξουσα ταξινόμηση ενός πίνακα 10 θέσεων παρουσιάζεται στον κώδικα που ακολουθεί.

\lstinputlisting[caption = Ο αλγόριθμος ταξινόμησης με εισαγωγή (insertion\_sort.cpp)]{lab03/insertion_sort.cpp}

\lstinputlisting[caption = Κλήση της συνάρτησης insertion\_sort (sort1.cpp)]{lab03/sort1.cpp}

\lstinputlisting[style=DOS]{lab03/sort1.out}

\subsection{Ταξινόμηση με συγχώνευση}
Η ταξινόμηση με συγχώνευση (merge-sort) είναι αναδρομικός αλγόριθμος και στηρίζεται στη συγχώνευση ταξινομημένων υποακολουθιών έτσι ώστε να δημιουργούνται νέες ταξινομημένες υποακολουθίες. Μια υλοποίηση του κώδικα ταξινόμησης με συγχώνευση παρουσιάζεται στη συνέχεια. 

\lstinputlisting[caption = Ο αλγόριθμος ταξινόμησης με συγχώνευση (merge\_sort.cpp), multicols=2]{lab03/merge_sort.cpp}

\lstinputlisting[caption = Κλήση της συνάρτησης merge\_sort (sort2.cpp)]{lab03/sort2.cpp}

\lstinputlisting[style=DOS]{lab03/sort2.out}

\subsection{Γρήγορη ταξινόμηση}
Ο κώδικας της γρήγορης ταξινόμησης  παρουσιάζεται στη συνέχεια. Πρόκειται για κώδικα ο οποίος καλείται αναδρομικά σε υποακολουθίες των δεδομένων και σε κάθε κλήση επιλέγει ένα στοιχείο (pivot) και διαχωρίζει τα υπόλοιπα στοιχεία έτσι ώστε αριστερά να είναι τα στοιχεία που είναι μικρότερα του pivot και δεξιά αυτά τα οποία είναι μεγαλύτερα. 

\lstinputlisting[caption = Ο αλγόριθμος γρήγορης ταξινόμησης (quick\_sort.cpp)]{lab03/quick_sort.cpp}

\lstinputlisting[caption = Κλήση της συνάρτησης quick\_sort (sort3.cpp)]{lab03/sort3.cpp}

\lstinputlisting[style=DOS]{lab03/sort3.out}

\subsection{Ταξινόμηση κατάταξης}
ο αλγόριθμος ταξινόμησης κατάταξης (rank-sort) λειτουργεί ως εξής: Για κάθε στοιχείο του δεδομένου πίνακα a που επιθυμούμε να ταξινομήσουμε υπολογίζεται μια τιμή κατάταξης (rank). Η τιμή κατάταξης ενός στοιχείου του πίνακα είναι το πλήθος των μικρότερων από αυτό στοιχείων συν το πλήθος των ίσων με αυτό στοιχείων που έχουν μικρότερο δείκτη σε σχέση με αυτό το στοιχείο (δηλαδή βρίσκονται αριστερά του).  Δηλαδή ισχύει ότι η τιμή κατάταξης ενός στοιχείου x του πίνακα είναι ίση με το άθροισμα 2 όρων: του πλήθους των μικρότερων στοιχείων του x από όλο τον πίνακα  και του πλήθους των ίσων με το x στοιχείων που έχουν μικρότερο δείκτη σε σχέση με το x. Για παράδειγμα στην ακολουθία τιμών a=[44, 21, 78, 16, 56, 21] θα πρέπει να δημιουργηθεί ένας νέος πίνακας r = [3, 1, 5, 0, 4, 2]. Έχοντας υπολογίσει τον πίνακα r θα πρέπει τα στοιχεία του a να αντιγραφούν σε ένα νέο βοηθητικό πίνακα temp έτσι ώστε κάθε τιμή που υπάρχει στον πίνακα r να λειτουργεί ως δείκτης για το που πρέπει να τοποθετηθεί το αντίστοιχο στοιχείο του a στον πίνακα temp. Τέλος θα πρέπει να αντιγραφεί ο πίνακας temp στον πίνακα a.
Στη συνέχεια παρουσιάζεται ο κώδικας του αλγορίθμου rank-sort. Παρουσιάζονται δύο υλοποιήσεις. Η πρώτη υλοποίηση (rank\_sort) αφορά τον αλγόριθμο όπως έχει περιγραφεί παραπάνω ενώ η δεύτερη (rank\_sort\_in\_place) είναι από το βιβλίο ``Δομές Δεδομένων, Αλγόριθμοι και Εφαρμογές στη C++ του Sartaj Sahnii'' \cite{sahnii2004} και δεν απαιτεί τη χρήση του βοηθητικού πίνακα temp, συνεπώς είναι αποδοτικότερος. 

\lstinputlisting[caption = Ο αλγόριθμος ταξινόμησης κατάταξης (sort4.cpp),multicols=2]{lab03/sort4.cpp}

\lstinputlisting[style=DOS]{lab03/sort4.out}

\subsection{Σταθερή ταξινόμηση (stable sorting)}
Ένας αλγόριθμος ταξινόμησης είναι stable αν τα στοιχεία με την ίδια τιμή εμφανίζονται με την ίδια σειρά με την οποία βρισκόταν στην αρχική λίστα και στην ταξινομημένη λίστα \cite{hackernoon}. Για παράδειγμα, αν σε μια λίστα εγγραφών φοιτητών/φοιτητριών (όνομα - βαθμός) πραγματοποιηθεί σταθερή ταξινόμηση με βάση το βαθμό, θα πρέπει οι φοιτητές με τον ίδιο βαθμό να μην αλλάξουν σειρά μεταξύ τους σε σχέση με τη σειρά που είχαν στην αρχική λίστα. Ο ακόλουθος κώδικας διαβάζει τα στοιχεία υποθετικών ατόμων από το αρχείο students20.txt και εφαρμόζοντας αλγορίθμους ταξινόμησης που παρουσιάστηκαν νωρίτερα καθώς και αλγορίθμους ταξινόμησης της STL παρουσιάζει τα δεδομένα ταξινομημένα. 

\lstinputlisting[caption = Σταθερή ταξινόμηση (stable.cpp),multicols=2]{lab03/stable.cpp}

\lstinputlisting[style=DOS]{lab03/stable.out}


\section{Αλγόριθμοι αναζήτησης}

\subsection{Σειριακή αναζήτηση}
Η σειριακή αναζήτηση είναι ο απλούστερος αλγόριθμος αναζήτησης. Εξετάζει τα στοιχεία ένα προς ένα στη σειρά μέχρι να βρει το στοιχείο που αναζητείται. Το πλεονέκτημα του αλγορίθμου είναι ότι μπορεί να εφαρμοστεί σε μη ταξινομημένους πίνακες.

\lstinputlisting[caption = Ο αλγόριθμος σειριακής αναζήτησης (search1.cpp)]{lab03/search1.cpp}

\lstinputlisting[style=DOS]{lab03/search1.out}

\subsection{Δυαδική αναζήτηση}
Η δυαδική αναζήτηση μπορεί να εφαρμοστεί μόνο σε ταξινομημένα δεδομένα. Διαιρεί επαναληπτικά την ακολουθία σε 2 υποακολουθίες και απορρίπτει την ακολουθία στην οποία συμπεραίνει ότι δεν μπορεί να βρεθεί το στοιχείο. 

\lstinputlisting[caption = Ο αλγόριθμος δυαδικής αναζήτησης σε μη αναδρομική και σε αναδρομική έκδοση (binary\_search.cpp)]{lab03/binary_search.cpp}

\lstinputlisting[caption = Κλήση της συνάρτησης binary\_search (search2.cpp)]{lab03/search2.cpp}

\lstinputlisting[style=DOS]{lab03/search2.out}

\subsection{Αναζήτηση με παρεμβολή}
Η αναζήτηση με παρεμβολή (interpolation-search) είναι μια παραλλαγή της δυαδικής αναζήτησης και μπορεί να εφαρμοστεί μόνο σε ταξινομημένα δεδομένα. Αντί να χρησιμοποιηθεί η τιμή 50\% για να διαχωριστούν τα δεδομένα σε 2 ισομεγέθεις λίστες (όπως συμβαίνει στη δυαδική αναζήτηση) υπολογίζεται μια τιμή η οποία εκτιμάται ότι θα οδηγήσει πλησιέστερα στο στοιχείο που αναζητείται. Αν l είναι ο δείκτης του αριστερότερου στοιχείου της ακολουθίας και r o δείκτης του δεξιότερου στοιχείου της ακολουθίας τότε υπολογίζεται ο συντελεστής 
c = (key−a[l])/(a[r]−a[l]) όπου key είναι το στοιχείο προς αναζήτηση και a είναι η ακολουθία τιμών στην οποία αναζητείται το key. Η ακολουθία των δεδομένων διαχωρίζεται με βάση τον συντελεστή c σε δύο υποακολουθίες. Η διαδικασία επαναλαμβάνεται ανάλογα με τη δυαδική αναζήτηση. Στη συνέχεια παρουσιάζεται ο κώδικας της αναζήτησης με παρεμβολή.

\lstinputlisting[caption = Ο αλγόριθμος αναζήτησης με παρεμβολή (interpolation\_search.cpp)]{lab03/interpolation_search.cpp}

\lstinputlisting[caption = Κλήση της συνάρτησης interpolation\_search search3.cpp]{lab03/search3.cpp}

\lstinputlisting[style=DOS]{lab03/search3.out}

\section{Παραδείγματα}
\subsection{Παράδειγμα 1}
Γράψτε πρόγραμμα που να συγκρίνει τους χρόνους εκτέλεσης των αλγορίθμων ταξινόμησης insertion-sort, merge-sort, quick-sort καθώς και του αλγορίθμου ταξινόμησης της βιβλιοθήκης STL (συνάρτηση sort). Η σύγκριση να αφορά τυχαία δεδομένα τύπου float με τιμές στο διάστημα από -1.000 έως 1.000. Τα μεγέθη των πινάκων που θα ταξινομηθούν να είναι 5.000, 10.000, 20.0000, 40.000, 80.000, 160.0000 και 320.000 αριθμών. 

\lstinputlisting[caption = Σύγκριση χρόνου εκτέλεσης αλγορίθμων ταξινόμησης (lab03\_ex1.cpp),multicols=2]{lab03/lab03_ex1.cpp}

\lstinputlisting[style=DOS]{lab03/lab03_ex1.out}


\subsection{Παράδειγμα 2}
Γράψτε πρόγραμμα που να συγκρίνει τους χρόνους εκτέλεσης των αλγορίθμων αναζήτησης binary-search, interpolation-search και του αλγορίθμου αναζήτησης της βιβλιοθήκης STL binary\_search για ταξινομημένα ακέραια δεδομένα με τιμές στο διάστημα από 0  έως 10.000.000. Η σύγκριση να εξετάζει τα ακόλουθα μεγέθη πινάκων 5.000, 10.000, 20.000, 40.000, 80.000, 160.000 και 320.000 αριθμών. Οι χρόνοι εκτέλεσης να αφορούν τους συνολικούς χρόνους που απαιτούνται έτσι ώστε να αναζητηθούν 100.000 τυχαίες τιμές με καθένα από τους αλγορίθμους. 


\lstinputlisting[caption = Σύγκριση χρόνου εκτέλεσης αλγορίθμων ταξινόμησης (lab03\_ex2.cpp),multicols=2]{lab03/lab03_ex2.cpp}

\lstinputlisting[style=DOS]{lab03/lab03_ex2.out}

\section{Ασκήσεις}
\begin{enumerate}[nolistsep]
\item Ο αλγόριθμος bogosort αναδιατάσσει τυχαία τις τιμές ενός πίνακα μέχρι να προκύψει μια ταξινομημένη διάταξη. Γράψτε ένα πρόγραμμα που να υλοποιεί τον αλγόριθμο bogosort για την ταξινόμηση ενός πίνακα ακεραίων τιμών. Χρησιμοποιήστε τη συνάρτηση shuffle. 
\item Να υλοποιηθεί ο αλγόριθμος ταξινόμησης με επιλογή (selection sort) και να εφαρμοστεί για τη ταξινόμηση ενός πίνακα πραγματικών τιμών, ενός πίνακα ακεραίων και ενός πίνακα με λεκτικά (δηλαδή να γίνουν τρεις κλήσεις του αλγορίθμου). Ο αλγόριθμος ταξινόμησης με επιλογή ξεκινά εντοπίζοντας το μικρότερο στοιχείο και το τοποθετεί στη πρώτη θέση. Συνεχίζει, ακολουθώντας την ίδια διαδικασία χρησιμοποιώντας το τμήμα του πίνακα που δεν έχει ταξινομηθεί ακόμα. 
\item Γράψτε μια αναδρομική έκδοση του κώδικα για την ταξινόμηση με επιλογή (selection sort).
\item Υλοποιήστε τον αλγόριθμο radix sort (\href{https://en.wikipedia.org/wiki/Radix_sort}{https://en.wikipedia.org/wiki/Radix\_sort}) σε C++ και χρησιμοποιήστε τον για την ταξινόμηση ενός μεγάλου πίνακα ακεραίων.

\end{enumerate}


\begin{thebibliography}{9}
\bibitem{robbell}
A beginners guide to Big O notation, \href{https://rob-bell.net/2009/06/a-beginners-guide-to-big-o-notation}{https://rob-bell.net/2009/06/a-beginners-guide-to-big-o-notation}

\bibitem{sahnii2004}
Sartaj Sahnii. Δομές Δεδομένων, Αλγόριθμοι και Εφαρμογές στη C++. Εκδόσεις Τζιόλα, 2004.

\bibitem{hackernoon}
Stable Sorting, \href{https://hackernoon.com/stable-sorting-677453884792}{https://hackernoon.com/stable-sorting-677453884792}
\end{thebibliography}

