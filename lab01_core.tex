\section{Εισαγωγή}
Στο πρώτο αυτό εργαστήριο θα επιχειρηθεί μια παρουσίαση των βασικών γνώσεων που απαιτούνται έτσι ώστε να είναι δυνατή η κατανόηση των εργαστηρίων που ακολουθούν. Ειδικότερα, θα γίνει αναφορά σε δείκτες, στη δυναμική δέσμευση και αποδέσμευση μνήμης, στο πέρασμα παραμέτρων σε συναρτήσεις, στους πίνακες, στις δομές, στα αντικείμενα και τέλος στην ανάγνωση και εγγραφή σε αρχεία. Θα παρουσιαστούν λυμένα παραδείγματα καθώς και εκφωνήσεις ασκήσεων προς επίλυση. Αναλυτικότερη παρουσίαση των ανωτέρω θεμάτων γίνεται στα ελεύθερα διαθέσιμα βιβλία \cite{stamatiadis2017}, \cite{downey2012}, \cite{soulie2007}, \cite{hall2007} που παρατίθενται ως αναφορές στο τέλος του κειμένου του εργαστηρίου. Ο κώδικας όλων των παραδειγμάτων βρίσκεται στο \href{}{}.

\section{Δείκτες}
Κάθε θέση μνήμης στην οποία μπορούν να αποθηκευτούν δεδομένα βρίσκεται σε μια διεύθυνση μνήμης. Η δε μνήμη του υπολογιστή αποτελείται από ένα συνεχόμενο χώρο διευθύνσεων. Αν μια μεταβλητή δηλωθεί ως τύπου int * τότε η τιμή που θα λάβει ερμηνεύεται ως μια διεύθυνση που δείχνει σε μια θέση μνήμης η οποία περιέχει έναν ακέραιο. Από την άλλη μεριά το σύμβολο \& επιτρέπει τη λήψη της διεύθυνσης μιας μεταβλητής. Στον ακόλουθο κώδικα δηλώνονται 2 ακέραιες μεταβλητές (a και b) και ένας δείκτης (p) σε ακέραια τιμή. Ο δείκτης p λαμβάνει ως τιμή τη διεύθυνση της μεταβλητής a. Στη συνέχεια, οι μεταβλητές a και b λαμβάνουν τιμές μέσω του δείκτη p. Για να συμβεί αυτό γίνεται έμμεση αναφορά ή αλλιώς αποαναφορά (dereference) του δείκτη με το *p. Συνεπώς, το *p αντιστοιχεί στο περιεχόμενο της διεύθυνσης μνήμης που έχει ο δείκτης p.

\lstinputlisting[caption=Παράδειγμα με δείκτες (lab01\_01.cpp)]{lab01/lab01_01.cpp}
\lstinputlisting[style=DOS]{lab01/lab01_01.out}

Ένα συνηθισμένο λάθος με δείκτες παρουσιάζεται όταν γίνεται dereference ενός δείκτη (δηλαδή, δεδομένου ενός δείκτη p όταν χρησιμοποιείται το *p) χωρίς ο δείκτης να έχει αρχικοποιηθεί πρώτα δείχνοντας σε μια έγκυρη θέση μνήμης. Σε αυτή την περίπτωση το πρόγραμμα καταρρέει. 

\lstinputlisting[caption=Λανθασμένη χρήση δείκτη (lab01\_02.cpp)]{lab01/lab01_02.cpp}

\begin{lstlisting}[style=DOS]
segmentation fault
\end{lstlisting}

Αν η μεταγλώττιση του κώδικα γίνει με το flag -Wall τότε θα εμφανιστεί μήνυμα που θα προειδοποιεί για τη λάθος χρήση του δείκτη.

\begin{lstlisting}[style=DOS]
g++ -Wall lab01_02.cpp -o lab01_02
lab01_02.cpp: In function 'int main(int, char**)':
lab01_02.cpp:8:11: warning: 'p' is used uninitialized in this function [-Wuninitialized]
     *p = 2;
           ^
\end{lstlisting}

\section{Κλήση με τιμή και κλήση με αναφορά}
Οι δείκτες μπορούν να χρησιμοποιηθούν έτσι ώστε να επιτευχθεί, εφόσον απαιτείται, κλήση με αναφορά (call by reference) στις παραμέτρους μιας συνάρτησης και όχι κλήση με τιμή (call by value) που είναι ο προκαθορισμένος τρόπος κλήσης συναρτήσεων. Στο παράδειγμα που ακολουθεί η συνάρτηση swap (σε αντίθεση με τη συνάρτηση swap\_impotent) επιτυγχάνει την αντιμετάθεση των δύο μεταβλητών που δέχεται ως ορίσματα καθώς χρησιμοποιεί δείκτες που αναφέρονται στις ίδιες τις μεταβλητές του κυρίου προγράμματος και όχι σε αντίγραφά τους. 

\lstinputlisting[caption=Αντιμετάθεση μεταβλητών με δείκτες (lab01\_03.cpp)]{lab01/lab01_03.cpp}

\lstinputlisting[style=DOS]{lab01/lab01_03.out}


Η γλώσσα C++ προκειμένου να απλοποιήσει την κλήση με αναφορά εισήγαγε την έννοια των ψευδωνύμων (aliases). Τοποθετώντας στη δήλωση μιας παραμέτρου συνάρτησης το σύμβολο \& η παράμετρος λειτουργεί ως ψευδώνυμο για τη μεταβλητή που περνά στην αντίστοιχη θέση. Η συγκεκριμένη συμπεριφορά παρουσιάζεται στον ακόλουθο κώδικα.

\lstinputlisting[caption=Αντιμετάθεση μεταβλητών με αναφορές (lab01\_04.cpp)]{lab01/lab01_04.cpp}

\lstinputlisting[style=DOS]{lab01/lab01_04.out}


\section{Πίνακες}
Ένας  πίνακας είναι μια συλλογή από στοιχεία του ίδιου τύπου καθένα από τα οποία μπορεί να αναγνωριστεί από την τιμή ενός ακεραίου δείκτη (index).  Το γεγονός αυτό επιτρέπει την τυχαία προσπέλαση (random access) στα στοιχεία του πίνακα. Οι δείκτες των πινάκων ξεκινούν από το μηδέν. 

\subsection{Μονοδιάστατοι πίνακες}
Οι μονοδιάστατοι πίνακες είναι η πλέον απλή δομή δεδομένων. Η αναφορά στα στοιχεία του πίνακα γίνεται συνήθως με μια δομή επανάληψης (π.χ. for). Στο ακόλουθο παράδειγμα δύο μονοδιάστατοι πίνακες αρχικοποιούνται κατά τη δήλωσή τους και εν συνεχεία υπολογίζεται το εσωτερικό γινόμενό τους δηλαδή το άθροισμα των γινομένων των στοιχείων των πινάκων που βρίσκονται στην ίδια θέση.

\lstinputlisting[caption=Υπολογισμός εσωτερικού γινομένου δύο πινάκων (lab01\_05.cpp)]{lab01/lab01_05.cpp}

\lstinputlisting[style=DOS]{lab01/lab01_05.out}


\subsection{Δυναμικοί πίνακες}
Δυναμικοί πίνακες χρησιμοποιούνται όταν το μέγεθος του πίνακα πρέπει να αλλάζει κατά τη διάρκεια εκτέλεσης του προγράμματος και συνεπώς δεν μπορεί να ορισθεί κατά τη μεταγλώττιση. Πριν χρησιμοποιηθεί ένας δυναμικός πίνακας θα πρέπει δεσμευτούν οι απαιτούμενες θέσεις μνήμης. Επίσης, θα πρέπει να απελευθερωθεί ο χώρος που καταλαμβάνει όταν πλέον δεν χρησιμοποιείται. Στο ακόλουθο παράδειγμα ο χρήστης εισάγει το μέγεθος ενός μονοδιάστατου πίνακα και ο απαιτούμενος χώρος δεσμεύεται κατά την εκτέλεση του κώδικα. Στη συνέχεια ο πίνακας γεμίζει με τυχαίες ακέραιες τιμές στο διάστημα [1,100]. Παρουσιάζονται δύο εκδόσεις του κώδικα, μια που χρησιμοποιεί τις συναρτήσεις malloc και free της γλώσσας C και μια που χρησιμοποιεί τις εντολές new και delete της C++ για τη δέσμευση και την αποδέσμευση μνήμης. Επιπλέον, χρησιμοποιείται διαφορετικός τρόπος για τη δημιουργία των τυχαίων τιμών στα δύο προγράμματα.

\lstinputlisting[caption=Δημιουργία δυναμικού πίνακα με συναρτήσεις της C (lab01\_06.cpp)]{lab01/lab01_06.cpp}

\lstinputlisting[style=DOS]{lab01/lab01_06.out}

\lstinputlisting[caption=Δημιουργία δυναμικού πίνακα με συναρτήσεις της C++ (lab01\_07.cpp),label=lst:lab01_07.cpp]{lab01/lab01_07.cpp}
\lstinputlisting[style=DOS]{lab01/lab01_07.out}

Για να γίνει η μεταγλώττιση του κώδικα \ref{lst:lab01_07.cpp} θα πρέπει να χρησιμοποιηθεί το flag -std=c++11 όπως φαίνεται στην ακόλουθη εντολή.

\begin{lstlisting}[style=DOS]
g++ -std=c++11 lab01_07.cpp -o lab01_07
\end{lstlisting}

\subsection{Πίνακας ως παράμετρος συνάρτησης}
Ένας πίνακας μπορεί να περάσει ως παράμετρος σε μια συνάρτηση. Συχνά χρειάζεται να περάσουν ως παράμετροι και οι διαστάσεις του πίνακα. Στον ακόλουθο κώδικα η συνάρτηση simple\_stats δέχεται ως παράμετρο έναν μονοδιάστατο  πίνακα ακεραίων και το πλήθος των στοιχείων του και επιστρέφει μέσω κλήσεων με αναφορά το μέσο όρο, το ελάχιστο και το μέγιστο από όλα τα στοιχεία του πίνακα.

\lstinputlisting[caption=Δυναμικός πίνακας ως παράμετρος συνάρτησης (lab01\_08.cpp)]{lab01/lab01_08.cpp}

\lstinputlisting[style=DOS]{lab01/lab01_08.out}

\subsection{Δισδιάστατοι πίνακες}
Ένας δισδιάστατος πίνακας αποτελείται από γραμμές και στήλες και η αναφορά στα στοιχεία του γίνεται με δύο  δείκτες από τους οποίους ο πρώτος δείκτης υποδηλώνει τη γραμμή και ο δεύτερος υποδηλώνει τη στήλη του πίνακα. Οι πίνακες είναι ιδιαίτερα σημαντικοί για την εκτέλεση μαθηματικών υπολογισμών (π.χ. πολλαπλασιασμό πινάκων, επίλυση συστημάτων γραμμικών εξισώσεων κ.α.). Στον ακόλουθο κώδικα δίνεται ένα παράδειγμα δήλωσης ενός δισδιάστατου πίνακα 5 x 4 ο οποίος περνά ως παράμετρος στη συνάρτηση sums\_row\_wise. Η δε συνάρτηση επιστρέφει το άθροισμα κάθε γραμμής του πίνακα.

\lstinputlisting[caption=Δισδιάστατος πίνακας ως παράμετρος συνάρτησης (lab01\_09.cpp)]{lab01/lab01_09.cpp}

\lstinputlisting[style=DOS]{lab01/lab01_09.out}


\subsection{Πολυδιάστατοι πίνακες}
Αν και οι μονοδιάστατοι και οι δισδιάστατοι πίνακες χρησιμοποιούνται συχνότερα, υποστηρίζονται και πίνακες μεγαλύτερων διαστάσεων. Στη συνέχεια δίνεται ένα παράδειγμα δήλωσης και αρχικοποίησης ενός τρισδιάστατου πίνακα 3x3x2 και ενός τετραδιάστατου πίνακα 3x3x3x2.

\lstinputlisting[caption=Δήλωση και αρχικοποίηση τρισδιάστατου και τετραδιάστατου πίνακα (lab01\_10.cpp)]{lab01/lab01_10.cpp}


\subsection{Πριονωτοί πίνακες}
Εφόσον ένας πολυδιάστατος πίνακας δημιουργείται δυναμικά μπορεί να οριστεί με τέτοιο τρόπο έτσι ώστε η κάθε γραμμή του να μην έχει τον ίδιο αριθμό στοιχείων. Στον ακόλουθο κώδικα δημιουργείται ένας δισδιάστατος πίνακας 5 γραμμών με την πρώτη γραμμή να έχει 1 στοιχείο και κάθε επόμενη γραμμή ένα περισσότερο στοιχείο από την προηγούμενη της.

\lstinputlisting[caption=Παράδειγμα πριονωτού πίνακα με 5 γραμμές (lab01\_11.cpp)]{lab01/lab01_11.cpp}

\lstinputlisting[style=DOS]{lab01/lab01_11.out}

\section{Δομές}
Οι δομές χρησιμοποιούνται όταν απαιτούνται σύνθετοι τύποι δεδομένων οι οποίοι αποτελούνται από επιμέρους στοιχεία. Στο παράδειγμα που ακολουθεί ορίζεται η δομή Book με 3 πεδία. Στη συνέχεια δημιουργούνται 3 μεταβλητές που πρόκειται να αποθηκεύσουν πληροφορίες για ένα βιβλίο η κάθε μια.  Η τρίτη μεταβλητή είναι δείκτης προς τη δομή Book και προκειμένου να χρησιμοποιηθεί θα πρέπει πρώτα να δεσμευθεί μνήμη (new) ενώ με τον τερματισμό του προγράμματος θα πρέπει η μνήμη αυτή να επιστραφεί στο σύστημα (delete).

\lstinputlisting[caption=Μεταβλητές τύπου δομής Book (lab01\_12.cpp)]{lab01/lab01_12.cpp}

\lstinputlisting[style=DOS]{lab01/lab01_12.out}

\section{Κλάσεις - Αντικείμενα}
Ο αντικειμενοστρεφής προγραμματισμός εντοπίζει τα αντικείμενα που απαρτίζουν την εφαρμογή και τα συνδυάζει προκειμένου να επιτευχθεί η απαιτούμενη λειτουργικότητα. Για κάθε αντικείμενο γράφεται μια κλάση η οποία είναι υπεύθυνη για τη δημιουργία των επιμέρους στιγμιοτύπων (object instances). Κάθε αντικείμενο έχει μεταβλητές και συναρτήσεις οι οποίες μπορεί να είναι είτε ιδιωτικές (private) είτε δημόσιες (public) (είτε προστατευμένες-protected).  Τα ιδιωτικά μέλη χρησιμοποιούνται εντός της κλάσης που ορίζει το αντικείμενο ενώ τα δημόσια μπορούν να χρησιμοποιηθούν και από κώδικα εκτός της κλάσης. Στο ακόλουθο παράδειγμα ορίζεται η κλάση Box η οποία έχει 3 ιδιωτικά μέλη (length, width, height) και 1 δημόσιο μέλος,  τη συνάρτηση volume. Στη main δημιουργούνται με τη βοήθεια του κατασκευαστή (constructor) δύο αντικείμενα (στιγμιότυπα) της κλάσης Box και καλείται για καθένα από αυτά η δημόσια συνάρτηση μέλος της Box, volume. 

\lstinputlisting[caption=Παράδειγμα κλάσης Box (lab01\_13.cpp)]{lab01/lab01_13.cpp}

\lstinputlisting[style=DOS]{lab01/lab01_13.out}

\section{Αρχεία}
Συχνά χρειάζεται να αποθηκεύσουμε δεδομένα σε αρχεία ή να επεξεργαστούμε δεδομένα τα οποία βρίσκονται σε αρχεία. Ο ακόλουθος κώδικας πρώτα δημιουργεί έναν αρχείο με 100 τυχαίους ακεραίους στον τρέχοντα κατάλογο και στη συνέχεια ανοίγει το αρχείο και εμφανίζει τα στοιχεία του.

\subsection{Εγγραφή και ανάγνωση δεδομένων από αρχείο με συναρτήσεις της C}

\lstinputlisting[caption=Εγγραφή 100 ακέραιων αριθμητικών δεδομένων σε αρχείο και ανάγνωση τους από το ίδιο αρχείο (lab01\_14.cpp)]{lab01/lab01_14.cpp}

\begin{lstlisting}[style=DOS]
811 718 632 412 529 957 359 735 498 302 855 265 749 756 336 625 489 870 120 177 ...
\end{lstlisting}

\subsection{Εγγραφή και ανάγνωση δεδομένων από αρχείο με συναρτήσεις της C++}
Η C++ έχει προσθέσει νέους τρόπους με τους οποίους μπορεί να γίνει η αλληλεπίδραση με τα αρχεία. Ακολουθεί ένα παράδειγμα εγγραφής και ανάγνωσης δεδομένων από αρχείο με τη χρήση των fstream και sstream.

\lstinputlisting[label=lst:lab01_15.cpp,caption=Εγγραφή και ανάγνωση αλφαριθμητικών και ακεραίων από αρχείο (lab01\_15.cpp) (lab01\_15.cpp)]{lab01/lab01_15.cpp}

\lstinputlisting[style=DOS]{lab01/lab01_15.out}

\section{Παραδείγματα}
\subsection{Παράδειγμα 1}
Γράψτε κώδικα που να δημιουργεί μια δομή με όνομα Point και να έχει ως πεδία 2 double αριθμούς  (x και y) που υποδηλώνουν τις συντεταγμένες του σημείου στο καρτεσιανό επίπεδο. Δημιουργήστε έναν πίνακα με όνομα points με 5 σημεία με απευθείας εισαγωγή τιμών για τα ακόλουθα σημεία: (4, 17), (10, 21), (5, 32), (-1, 16), (-4, 7). Γράψτε τον κώδικα που εμφανίζει τα 2 πλησιέστερα σημεία. Ποια είναι τα πλησιέστερα σημεία και ποια η απόσταση μεταξύ τους;

\lstinputlisting[caption=Λύση παραδείγματος 1 (lab01\_16.cpp)]{lab01/lab01_16.cpp}

\lstinputlisting[style=DOS]{lab01/lab01_16.out}

\subsection{Παράδειγμα 2}
Με τη γεννήτρια τυχαίων αριθμών mt19937 δημιουργήστε 10000 τυχαίες ακέραιες τιμές στο διάστημα 0 έως 10000 με seed την τιμή 1729. Τοποθετήστε τις τιμές σε ένα δισδιάστατο πίνακα 100 x 100 έτσι ώστε να συμπληρώνονται οι τιμές στον πίνακα κατά σειρές από πάνω προς τα κάτω και από αριστερά προς τα δεξιά. Να υπολογιστεί το άθροισμα της κάθε γραμμής του πίνακα. Ποιος είναι ο αριθμός της γραμμής με το μεγαλύτερο άθροισμα και ποιο είναι αυτό;

\lstinputlisting[caption=Λύση παραδείγματος 2 (lab01\_17.cpp)]{lab01/lab01_17.cpp}

\lstinputlisting[style=DOS]{lab01/lab01_17.out}

\subsection{Παράδειγμα 3}
Γράψτε 10000 τυχαίες ακέραιες τιμές στο διάστημα [1,10000] στο αρχείο data\_int\_10000.txt χρησιμοποιώντας τις συναρτήσεις rand και srand και seed την τιμή 1729. Διαβάστε τις τιμές από το αρχείο. Εντοπίστε τη μεγαλύτερη τιμή στα δεδομένα. Ποιες είναι οι τιμές  που εμφανίζονται τις περισσότερες φορές στα δεδομένα;

\lstinputlisting[caption=Λύση παραδείγματος 3 (lab01\_18.cpp)]{lab01/lab01_18.cpp}

\lstinputlisting[style=DOS]{lab01/lab01_18.out}
 
\subsection{Παράδειγμα 4}
Γράψτε κώδικα που να δημιουργεί μια δομή με όνομα student (σπουδαστής) και να έχει ως πεδία το name (όνομα) τύπου string και το grade (βαθμός) τύπου int. Διαβάστε τα περιεχόμενα του αρχείου που έχει δημιουργηθεί με τον κώδικα \ref{lst:lab01_15.cpp} (data\_student\_struct10.txt) και τοποθετήστε τα σε κατάλληλο πίνακα. Βρείτε τα ονόματα και το μέσο όρο βαθμολογίας των σπουδαστών με βαθμό άνω του μέσου όρου όλων των σπουδαστών. Θεωρείστε ότι οι βαθμοί έχουν αποθηκευτεί στο αρχείο data\_student\_struct10.txt ως ακέραιοι αριθμοί από το 0 μέχρι και το 100, αλλά η εμφάνισή τους θα πρέπει να γίνεται εφόσον πρώτα διαιρεθούν με το 10. Δηλαδή, ο βαθμός 55 αντιστοιχεί στο βαθμό 5.5.

\lstinputlisting[caption=Λύση παραδείγματος 4 (lab01\_19.cpp)]{lab01/lab01_19.cpp}

\lstinputlisting[style=DOS]{lab01/lab01_19.out}

\section{Ασκήσεις}
\begin{enumerate}
\item Γράψτε μια συνάρτηση που να δέχεται έναν πίνακα ακεραίων και το μέγεθός του και να επιστρέφει το μέσο όρο των τιμών καθώς και το πλήθος των τιμών που απέχουν το πολύ 10\% από το μέσο όρο. Δοκιμάστε την κλήση της συνάρτησης για έναν πίνακα 100 θέσεων με τυχαίες ακέραιες τιμές στο διάστημα [1,100] οι οποίες θα δημιουργηθούν με τη χρήση των συναρτήσεων srand() και rand() της C. Χρησιμοποιήστε ως seed για την αρχικοποίηση των τυχαίων τιμών την τιμή 12345.

\item Γράψτε πρόγραμμα που να διαβάζει τα στοιχεία υπαλλήλων (όνομα, μισθό και έτη προϋπηρεσίας) από το αρχείο data\_ypallhlos\_struct20.txt και να εμφανίζει τα στοιχεία του κάθε υπαλλήλου μέσω μιας συνάρτησης που θα δέχεται ως παράμετρο μια μεταβλητή τύπου δομής υπαλλήλου. Στη συνέχεια να υπολογίζει και να εμφανίζει το ποσό που θα συγκεντρωθεί αν για κάθε υπάλληλο με περισσότερα από 5 έτη προϋπηρεσίας παρακρατηθεί το 5\% του μισθού του ενώ για τους υπόλοιπους υπαλλήλους παρακρατηθεί το 7\% του μισθού τους.

\item Γράψτε το προηγούμενο πρόγραμμα ξανά χρησιμοποιώντας κλάση στη θέση της δομής. Επιπλέον ορίστε constructor και getters/setters για τα μέλη δεδομένων του αντικειμένου υπάλληλος.

\item Γράψτε ένα πρόγραμμα που να γεμίζει έναν πίνακα a, 5 γραμμών και 5 στηλών, με τυχαίες ακέραιες τιμές στο διάστημα 1 έως και 1000 (χρησιμοποιήστε ως seed την τιμή 12345). Γράψτε μια συνάρτηση που να δέχεται ως παράμετρο τον πίνακα a και να επιστρέφει σε μονοδιάστατο πίνακα col το άθροισμα των τιμών κάθε στήλης του πίνακα. Οι τιμές που επιστρέφονται να εμφανίζονται στο κύριο πρόγραμμα το οποίο να εμφανίζει επιπλέον και τον αριθμό στήλης με το μεγαλύτερο άθροισμα.
\end{enumerate}



\begin{thebibliography}{9}
\bibitem{stamatiadis2017}
Σταμάτης Σταματιάδης. Εισαγωγή στη γλώσσα προγραμματισμού C++11. Τμήμα Επιστήμης και Τεχνολογίας Υλικών, Πανεπιστήμιο Κρήτης, 2017, \href{https://www.materials.uoc.gr/el/undergrad/courses/ETY215/notes.pdf}{https://www.materials.uoc.gr/el/undergrad/courses/ETY215/notes.pdf}.

\bibitem{downey2012}
Allen B. Downey. How to think like a computer scientist, C++ version, 2012, \href{http://www.greenteapress.com/thinkcpp/}{http://www.greenteapress.com/thinkcpp/}. 

\bibitem{soulie2007}
Juan Souli\'e. C++ Language Tutorial. cplusplus.com, 2007, \href{http://www.cplusplus.com/files/tutorial.pdf}{http://www.cplusplus.com/files/tutorial.pdf}.

\bibitem{hall2007}
Brian Hall. Beej's Guide to C Programming, 2007, \href{http://beej.us/guide/bgc/}{http://beej.us/guide/bgc/}.

\end{thebibliography}
