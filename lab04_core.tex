\section{Εισαγωγή}
Οι γραμμικές λίστες είναι δομές δεδομένων που επιτρέπουν την αποθήκευση και την προσπέλαση στοιχείων έτσι ώστε τα στοιχεία να βρίσκονται σε μια σειρά με σαφώς ορισμένη την έννοια της θέσης καθώς και το ποιο στοιχείο προηγείται και ποιο έπεται καθενός. Σε χαμηλού επιπέδου γλώσσες προγραμματισμού όπως η C η υλοποίηση γραμμικών λιστών είναι ευθύνη του προγραμματιστή. Από την άλλη μεριά, γλώσσες υψηλού επιπέδου όπως η C++, η Java, η Python κ.α. προσφέρουν έτοιμες υλοποιήσεις γραμμικών λιστών. Ωστόσο, η γνώση υλοποίησης των συγκεκριμένων δομών (όπως και άλλων) αποτελεί βασική ικανότητα η οποία αποκτά ιδιαίτερη χρησιμότητα όταν ζητούνται εξειδικευμένες υλοποιήσεις. Για το λόγο αυτό στο συγκεκριμένο εργαστήριο θα παρουσιαστούν οι υλοποιήσεις γραμμικών λιστών αλλά και οι ενσωματωμένες δυνατότητες της C++ μέσω της STL.

\section{Γραμμικές λίστες}
Υπάρχουν δύο βασικοί τρόποι αναπαράστασης γραμμικών λιστών, η στατική αναπαράσταση η οποία γίνεται με τη χρήση πινάκων και η αναπαράσταση με συνδεδεμένη λίστα η οποία γίνεται με τη χρήση δεικτών. 

\subsection{Στατικές γραμμικές λίστες}
Στη στατική γραμμική λίστα τα δεδομένα αποθηκεύονται σε ένα πίνακα. Κάθε στοιχείο της στατικής λίστας μπορεί να προσπελαστεί με βάση τη θέση του στον ίδιο σταθερό χρόνο με όλα τα άλλα στοιχεία άσχετα με τη θέση στην οποία βρίσκεται (τυχαία προσπέλαση). Ο κώδικας υλοποίησης μιας στατικής λίστας με μέγιστη χωρητικότητα 50.000 στοιχείων παρουσιάζεται στη συνέχεια.

\lstinputlisting[caption = Υλοποίηση στατικής γραμμικής λίστας (static\_list.cpp),label=lst:static_list.cpp]{lab04/static_list.cpp}

\lstinputlisting[caption = Παράδειγμα με στατική γραμμική λίστα (list1.cpp)]{lab04/list1.cpp}

\lstinputlisting[style=DOS]{lab04/list1.out}

Οι στατικές γραμμικές λίστες έχουν τα ακόλουθα πλεονεκτήματα:
\begin{itemize}[nolistsep]
\item Εύκολη υλοποίηση. 
\item Σταθερός χρόνος $O(1)$ εντοπισμού στοιχείου με βάση τη θέση του.
\item Γραμμικός χρόνος $O(n)$ για αναζήτηση ενός στοιχείου ή λογαριθμικός χρόνος $O(log(n))$ αν τα στοιχεία είναι ταξινομημένα.
\end{itemize}

Ωστόσο, οι στατικές γραμμικές λίστες έχουν και μειονεκτήματα τα οποία παρατίθενται στη συνέχεια:
\begin{itemize}[nolistsep]
\item Δέσμευση μεγάλου τμήματος μνήμης ακόμη και όταν η λίστα είναι άδεια ή περιέχει λίγα στοιχεία. 
\item Επιβολή άνω ορίου στα δεδομένα τα οποία μπορεί να δεχθεί (ο περιορισμός αυτός μπορεί να ξεπεραστεί με συνθετότερη υλοποίηση που αυξομειώνει το μέγεθος του πίνακα υποδοχής όταν αυτό απαιτείται).
\item Γραμμικός χρόνος $O(n)$ για εισαγωγή και διαγραφή στοιχείων του πίνακα.
\end{itemize}


\subsection{Συνδεδεμένες γραμμικές λίστες}
Η συνδεδεμένη γραμμική λίστα αποτελείται από μηδέν ή περισσότερους κόμβους. Κάθε κόμβος περιέχει δεδομένα και έναν ή περισσότερους δείκτες σε άλλους κόμβους της συνδεδεμένης λίστας. Συχνά χρησιμοποιείται ένας πρόσθετος κόμβος με όνομα head (κόμβος κεφαλής) που δείχνει στο πρώτο στοιχείο της λίστας και μπορεί να περιέχει επιπλέον πληροφορίες όπως το μήκος της. Στη συνέχεια παρουσιάζεται ο κώδικας που υλοποιεί μια απλά συνδεδεμένη λίστα.

\lstinputlisting[caption = Υλοποίηση συνδεδεμένης γραμμικής λίστας (linked\_list.cpp),label=lst:linked_list.cpp]{lab04/linked_list.cpp}

\lstinputlisting[caption = Παράδειγμα με συνδεδεμένη γραμμική λίστα (list2.cpp)]{lab04/list2.cpp}

\lstinputlisting[style=DOS]{lab04/list2.out}


Οι συνδεδεμένες γραμμικές λίστες έχουν τα ακόλουθα πλεονεκτήματα:
\begin{itemize}[nolistsep]
\item Καλή χρήση του αποθηκευτικού χώρου (αν και απαιτείται περισσότερος χώρος για την αποθήκευση κάθε κόμβου λόγω των δεικτών). 
\item Σταθερός χρόνος $O(1)$ για την εισαγωγή και διαγραφή στοιχείων.
\end{itemize}
Από την άλλη μεριά τα μειονεκτήματα των συνδεδεμένων λιστών είναι τα ακόλουθα:
\begin{itemize}[nolistsep]
\item Συνθετότερη υλοποίηση.
\item Δεν επιτρέπουν την απευθείας μετάβαση σε κάποιο στοιχείο με βάση τη θέση του.
\end{itemize}


\subsection{Γραμμικές λίστες της STL}
Τα containers της STL που μπορούν να λειτουργήσουν ως διατεταγμένες συλλογές (ordered collections) είναι τα ακόλουθα: vector, deque, arrays, list και forward\_list. 

\subsubsection{Vectors}
Τα vectors αλλάζουν αυτόματα μέγεθος καθώς προστίθενται ή αφαιρούνται στοιχεία σε αυτά. Τα δεδομένα τους τοποθετούνται σε συνεχόμενες θέσεις μνήμης. Περισσότερες πληροφορίες για τα vectors μπορούν να βρεθούν στην αναφορά \cite{g4gvector}.

\subsubsection{Deques}
Τα deques (double ended queues = ουρές με δύο άκρα) είναι παρόμοια με τα vectors αλλά μπορούν να προστεθούν ή να διαγραφούν στοιχεία τόσο από την αρχή όσο και από το τέλος τους. Περισσότερες πληροφορίες για τα deques μπορούν να βρεθούν στην αναφορά \cite{g4gdeque}.

\subsubsection{Arrays}
Τα arrays εισήχθησαν στη C++11 με στόχο να αντικαταστήσουν τους απλούς πίνακες της C. Περισσότερες πληροφορίες για τα arrays μπορούν να βρεθούν στην αναφορά \cite{g4garray}.

\subsubsection{Lists}
Οι lists είναι διπλά συνδεδεμένες λίστες. Δηλαδή κάθε κόμβος της λίστας διαθέτει έναν δείκτη προς το επόμενο και έναν δείκτη προς το προηγούμενο στοιχείο στη λίστα. Περισσότερες πληροφορίες για τις lists μπορούν να βρεθούν στην αναφορά \cite{g4glist}.

\subsubsection{Forward Lists}
Οι forward lists είναι απλά συνδεδεμένες λίστες με κάθε κόμβο να διαθέτει έναν δείκτη προς το επόμενο στοιχείο της λίστας. Περισσότερες πληροφορίες για τις forward lists μπορούν να βρεθούν στις αναφορές \cite{g4gforwardlist1}, \cite{g4gforwardlist2}.

\section{Παραδείγματα}
\subsection{Παράδειγμα 1}
Γράψτε ένα πρόγραμμα που να ελέγχεται από το ακόλουθο μενού και να πραγματοποιεί τις λειτουργίες που περιγράφονται σε μια απλά συνδεδεμένη λίστα με ακεραίους.
\begin{enumerate}[nolistsep]
\item Εμφάνιση στοιχείων λίστας. 
\item Εισαγωγή στοιχείου στο πίσω άκρο της λίστας.
\item Εισαγωγή στοιχείου σε συγκεκριμένη θέση.
\item Διαγραφή στοιχείου σε συγκεκριμένη θέση.
\item Διαγραφή όλων των στοιχείων που έχουν την τιμή.
\item Έξοδος
\end{enumerate}

\lstinputlisting[caption = Έλεγχος συνδεδεμένης λίστας ακεραίων μέσω μενού (lab04\_ex1.cpp)]{lab04/lab04_ex1.cpp}

\lstinputlisting[style=DOS]{lab04/lab04_ex1.out}


\subsection{Παράδειγμα 2}
Έστω μια τράπεζα που διατηρεί για κάθε πελάτη της το ονοματεπώνυμο του και το υπόλοιπο του λογαριασμού του. Για τις ανάγκες του παραδείγματος θα δημιουργηθούν τυχαίοι πελάτες ως εξής: το όνομα κάθε πελάτη να αποτελείται από 10 γράμματα που θα επιλέγονται με τυχαίο τρόπο από τα γράμματα της αγγλικής αλφαβήτου και το δε υπόλοιπο κάθε πελάτη να είναι ένας τυχαίος αριθμός από το 0 μέχρι το 5.000. 
Θα παρουσιαστούν τέσσερις εκδόσεις του ίδιου προγράμματος. Η μεν πρώτη θα υλοποιείται με στατική λίστα,  η δεύτερη με συνδεδεμένη λίστα η τρίτη με τη στατική γραμμική λίστα της C++, std::vector και η τέταρτη με τη συνδεδεμένη λίστα της C++, std::list. Και στις τέσσερις περιπτώσεις το πρόγραμμα θα πραγματοποιεί τις ακόλουθες λειτουργίες:
\begin{itemize}[noitemsep]
\item Θα δημιουργεί μια λίστα με 40.000 τυχαίους πελάτες.
\item Θα υπολογίζει το άθροισμα των υπολοίπων από όλους τους πελάτες που το όνομά τους ξεκινά με το χαρακτήρα Α.
\item Θα προσθέτει για κάθε πελάτη που το όνομά του ξεκινά με το χαρακτήρα G στην αμέσως επόμενη θέση έναν πελάτη με όνομα το αντίστροφο όνομα του πελάτη και το ίδιο υπόλοιπο λογαριασμού.
\item Θα διαγράφει όλους τους πελάτες που το όνομά τους ξεκινά με το χαρακτήρα Β.
\end{itemize}

\lstinputlisting[caption = Σύγκριση διαφορετικών υλοποιήσεων λίστας για το ίδιο πρόβλημα (lab04\_ex2.cpp)]{lab04/lab04_ex2.cpp}

\lstinputlisting[style=DOS]{lab04/lab04_ex2.out}

\section{Ασκήσεις}
\begin{enumerate}
\item Έστω η συνδεδεμένη λίστα που παρουσιάστηκε στον κώδικα \ref{lst:linked_list.cpp}. Προσθέστε μια συνάρτηση έτσι ώστε για  μια λίστα ταξινομημένων στοιχείων από το μικρότερο προς το μεγαλύτερο, να προσθέτει ένα ακόμα στοιχείο στην κατάλληλη θέση έτσι ώστε η λίστα να παραμένει ταξινομημένη.
\item Έστω η συνδεδεμένη λίστα που παρουσιάστηκε στον κώδικα \ref{lst:linked_list.cpp}. Προσθέστε μια συνάρτηση που να αντιστρέφει τη λίστα.
\item Υλοποιήστε τη στατική λίστα (κώδικας \ref{lst:static_list.cpp}) και τη συνδεδεμένη λίστα (κώδικας \ref{lst:linked_list.cpp}) με κλάσεις. Τροποποιήστε το παράδειγμα 1 έτσι ώστε να δίνεται επιλογή στο χρήστη να χρησιμοποιήσει είτε τη στατική είτε τη συνδεδεμένη λίστα προκειμένου να εκτελέσει τις ίδιες λειτουργίες πάνω σε μια λίστα. 
\item Υλοποιήστε μια κυκλικά συνδεδεμένη λίστα. Η κυκλική λίστα είναι μια απλά συνδεδεμένη λίστα στην οποία το τελευταίο στοιχείο της λίστας δείχνει στο πρώτο στοιχείο της λίστας. Η υλοποίηση θα πρέπει να συμπεριλαμβάνει και δύο δείκτες, έναν που να δείχνει στο πρώτο στοιχείο της λίστας και έναν που να δείχνει στο τελευταίο στοιχείο της λίστας. Προσθέστε τις απαιτούμενες λειτουργίες έτσι ώστε η λίστα να παρέχονται οι ακόλουθες λειτουργίες: εμφάνιση λίστας, εισαγωγή στοιχείου, διαγραφή στοιχείου, εμφάνιση πλήθους στοιχείων, εύρεση στοιχείου. Γράψτε πρόγραμμα που να δοκιμάζει τις λειτουργίες της λίστας.
\end{enumerate}

\begin{thebibliography}{9}
\bibitem{g4gvector}
Geeks for Geeks, Vector in C++ STL, \href{http://www.geeksforgeeks.org/vector-in-cpp-stl/}{http://www.geeksforgeeks.org/vector-in-cpp-stl/}.
\bibitem{g4gdeque}
Geeks for Geeks, Deque in C++ STL, \href{http://www.geeksforgeeks.org/deque-cpp-stl/}{http://www.geeksforgeeks.org/deque-cpp-stl/}.
\bibitem{g4garray}
Geeks for Geeks, Array class in C++ STL \href{http://www.geeksforgeeks.org/array-class-c/}{http://www.geeksforgeeks.org/array-class-c/}.
\bibitem{g4glist}
Geeks for Geeks, List in C++ STL  \href{http://www.geeksforgeeks.org/list-cpp-stl/}{http://www.geeksforgeeks.org/list-cpp-stl/}
\bibitem{g4gforwardlist1}
Geeks for Geeks, Forward List in C++ (Set 1) \href{http://www.geeksforgeeks.org/forward-list-c-set-1-introduction-important-functions/}{http://www.geeksforgeeks.org/forward-list-c-set-1-introduction-important-functions/}
\bibitem{g4gforwardlist2}
Geeks for Geeks, Forward List in C++ (Set 2) \href{http://www.geeksforgeeks.org/forward-list-c-set-2-manipulating-functions/}{http://www.geeksforgeeks.org/forward-list-c-set-2-manipulating-functions/}
\end{thebibliography}

