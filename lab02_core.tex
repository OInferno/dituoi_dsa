\section{Εισαγωγή}
Στο εργαστήριο αυτό παρουσιάζεται ο μηχανισμός των templates, τα lambdas και οι βασικές δυνατότητες της βιβλιοθήκης STL (Standard Template Library) της C++. Τα templates επιτρέπουν την κατασκευή γενικού κώδικα επιτρέποντας την αποτύπωση της λογικής μιας συνάρτησης ανεξάρτητα από τον τύπο των ορισμάτων που δέχεται. Από την άλλη μεριά, η βιβλιοθήκη STL, στην οποία γίνεται εκτεταμένη χρήση των templates παρέχει στον προγραμματιστή έτοιμη λειτουργικότητα για πολλές ενέργειες που συχνά συναντώνται κατά την ανάπτυξη εφαρμογών. Επιπλέον υλικό για την STL βρίσκεται στις αναφορές \cite{geeks4geeks_stl}, \cite{topcoder_stl1}, \cite{topcoder_stl2}, \cite{hackerearth_stl}. 


\section{Templates}
Τα templates (πρότυπα) είναι ένας μηχανισμός της C++ ο οποίος μπορεί να διευκολύνει τον προγραμματισμό. Η γλώσσα C++ είναι statically typed το οποίο σημαίνει ότι οι τύποι δεδομένων των μεταβλητών και σταθερών ελέγχονται κατά τη μεταγλώττιση. Το γεγονός αυτό μπορεί να οδηγήσει στην ανάγκη υλοποίησης διαφορετικών εκδόσεων μιας συνάρτησης έτσι ώστε να υποστηριχθεί η ίδια λογική για διαφορετικούς τύπους δεδομένων. Για παράδειγμα, η εύρεση της ελάχιστης τιμής ανάμεσα σε τρεις τιμές θα έπρεπε να υλοποιηθεί με δύο συναρτήσεις έτσι ώστε να υποστηρίζει τόσο τους ακεραίους όσο και τους πραγματικούς αριθμούς, όπως φαίνεται στον κώδικα που ακολουθεί.

\lstinputlisting[caption=Επανάληψη λογικής κώδικα (minmax.cpp)]{lab02/minmax.cpp}

\lstinputlisting[style=DOS]{lab02/minmax.out}

Με τη χρήση των templates μπορεί να γραφεί κώδικας που να υποστηρίζει ταυτόχρονα πολλούς τύπους δεδομένων.  Ειδικότερα, χρησιμοποιείται, η δεσμευμένη λέξη template και εντός των συμβόλων < και > τοποθετείται η λίστα των παραμέτρων του template. Ο μεταγλωττιστής αναλαμβάνει να δημιουργήσει όλες τις απαιτούμενες παραλλαγές των συναρτήσεων που θα χρειαστούν στον κώδικα που μεταγλωττίζει.

\lstinputlisting[caption=Χρήση template για αποφυγή επανάληψης λογικής κώδικα (minmaxt.cpp)]{lab02/minmaxt.cpp}

\lstinputlisting[style=DOS]{lab02/minmaxt.out}

θα πρέπει να σημειωθεί ότι στη θέση της δεσμευμένης λέξης typename μπορεί εναλλακτικά να χρησιμοποιηθεί η δεσμευμένη λέξη class.

\section{Η βιβλιοθήκη STL}
Η βιβλιοθήκη STL (Standard Template Library) της C++ προσφέρει έτοιμη λειτουργικότητα για πολλά θέματα τα οποία ανακύπτουν συχνά στον προγραμματισμό εφαρμογών. Πρόκειται για μια generic βιβλιοθήκη, δηλαδή κάνει εκτεταμένη χρήση των templates. Βασικά τμήματα της STL είναι οι containers (υποδοχείς), οι iterators (επαναλήπτες) και οι αλγόριθμοι.

\subsection{Containers}
H STL υποστηρίζει έναν αριθμό από containers στους οποίους μπορούν να αποθηκευτούν δεδομένα. Ένα από τα containers είναι το vector (διάνυσμα). Στον ακόλουθο κώδικα φαίνεται πως η χρήση του vector διευκολύνει τον προγραμματισμό καθώς δεν απαιτούνται εντολές διαχείρισης μνήμης ενώ η δομή είναι δυναμική, δηλαδή το μέγεθος της μπορεί να μεταβάλλεται κατά τη διάρκεια εκτέλεσης του προγράμματος. 

\lstinputlisting[caption=Παράδειγμα με προσθήκη στοιχείων σε vector (container1.cpp)]{lab02/container1.cpp}

\lstinputlisting[style=DOS]{lab02/container1.out}

Ένα container τύπου vector μπορεί να λάβει τιμές με πολλούς τρόπους. Στον ακόλουθο κώδικα παρουσιάζονται έξι διαφορετικοί τρόποι με τους οποίους μπορεί να γίνει αυτό.

\lstinputlisting[caption=Αρχικοποίηση vectors (container2.cpp)]{lab02/container2.cpp}
\lstinputlisting[style=DOS]{lab02/container2.out}

Τα containers χωρίζονται σε σειριακά (sequence containers) και συσχετιστικά (associative containers). Τα σειριακά containers είναι συλλογές ομοειδών στοιχείων στις οποίες κάθε στοιχείο  έχει συγκεκριμένη θέση μέσω της οποίας μπορούμε να αναφερθούμε σε αυτό. Τα σειριακά containers είναι τα εξής: 
\begin{itemize}[noitemsep]
\item array (πίνακας) 
\item deque (ουρά με δύο άκρα)
\item forward\_list (λίστα διανυόμενη προς τα εμπρός)
\item list (λίστα)
\item vector (διάνυσμα)
\end{itemize}

Τα συσχετιστικά containers παρουσιάζουν το πλεονέκτημα της γρήγορης προσπέλασης. Συσχετιστικά containers της STL είναι τα εξής: 
\begin{itemize}[noitemsep]
\item map (λεξικό)
\item unordered\_map (λεξικό χωρίς σειρά)
\item multimap (πολλαπλό λεξικό)
\item unordered\_multimap. (πολλαπλό λεξικό χωρίς σειρά)
\item set (σύνολο)
\item unordered\_set (σύνολο χωρίς σειρά)
\item multiset (πολλαπλό σύνολο)
\item unordered\_multiset (πολλαπλό σύνολο χωρίς σειρά)
\end{itemize}

Στη συνέχεια παρουσιάζεται ένα παράδειγμα χρήσης του συσχετιστικού container map. Δημιουργείται ένας τηλεφωνικός κατάλογος που περιέχει πληροφορίες της μορφής όνομα - τηλέφωνο και ο οποίος δίνει τη δυνατότητα να αναζητηθεί ένα τηλέφωνο με βάση ένα όνομα.

\lstinputlisting[caption=Παράδειγμα με map (container3.cpp)]{lab02/container3.cpp}

\lstinputlisting[style=DOS]{lab02/container3.out}


\subsection{Iterators}
Οι iterators αποτελούν γενικεύσεις των δεικτών και επιτρέπουν την πλοήγηση στα στοιχεία ενός container με τέτοιο τρόπο έτσι ώστε να μπορούν να χρησιμοποιηθούν οι ίδιοι αλγόριθμοι σε περισσότερα του ενός containers. Στον ακόλουθο κώδικα παρουσιάζεται το πέρασμα από τα στοιχεία ενός vector με τέσσερις διαφορετικούς τρόπους. Καθώς το container είναι τύπου vector παρουσιάζεται αρχικά το πέρασμα από τις τιμές του με τη χρήση δεικτοδότησης τύπου πίνακα. Στη συνέχεια χρησιμοποιείται η πρόσβαση στα στοιχεία του container μέσω του range for. Ακολούθως, χρησιμοποιείται ένας iterator για πέρασμα από την αρχή προς το τέλος και ένας reverse\_iterator για πέρασμα από το τέλος προς την αρχή. 

\lstinputlisting[caption = Τέσσερις διαφορετικοί τρόποι προσπέλασης των στοιχείων ενός vector (iterator1.cpp)]{lab02/iterator1.cpp}

\lstinputlisting[style=DOS]{lab02/iterator1.out}

Ακολουθεί κώδικας στον οποίο παρουσιάζεται το πέρασμα από όλα τα στοιχεία ενός map με τρεις διαφορετικούς τρόπους. Ο πρώτος τρόπος χρησιμοποιεί range for. Ο δεύτερος έναν iterator και ο τρίτος έναν reverse iterator.

\lstinputlisting[caption = Τρεις διαφορετικοί τρόποι προσπέλασης των στοιχείων ενός map (iterator2.cpp)]{lab02/iterator2.cpp}

\lstinputlisting[style=DOS]{lab02/iterator2.out}


\subsection{Αλγόριθμοι}
H STL διαθέτει πληθώρα αλγορίθμων που μπορούν να εφαρμοστούν σε διάφορα προβλήματα. Για παράδειγμα, προκειμένου να ταξινομηθούν δεδομένα μπορεί να χρησιμοποιηθεί η συνάρτηση sort της STL η οποία υλοποιεί τον αλγόριθμο \href{https://xlinux.nist.gov/dads/HTML/introspectiveSort.html}{Introspective Sort}. Στον ακόλουθο κώδικα πραγματοποιείται η ταξινόμηση αρχικά ενός στατικού πίνακα και στη συνέχεια εφόσον πρώτα οι τιμές του πίνακα μεταφερθούν σε ένα vector και ανακατευτούν τυχαία, πρώτα ταξινομούνται σε αύξουσα και μετά σε φθίνουσα σειρά. 

\lstinputlisting[caption = Ταξινόμηση με τη συνάρτηση sort της STL (sort1.cpp), multicols=2]{lab02/sort1.cpp}

\lstinputlisting[style=DOS]{lab02/sort1.out}

Στον παραπάνω κώδικά έγινε χρήση της δεσμευμένης λέξης auto στη δήλωση μεταβλητών. Η λέξη auto μπορεί να χρησιμοποιηθεί στη θέση ενός τύπου δεδομένων όταν γίνεται ταυτόχρονα δήλωση και ανάθεση τιμής σε μια μεταβλητή. Σε αυτή την περίπτωση ο μεταγλωττιστής της C++ είναι σε θέση να αναγνωρίσει τον πραγματικό τύπο της μεταβλητής από την τιμή που της εκχωρείται. 


Η συνάρτηση sort() εφαρμόζεται σε sequence containers πλην των list και forward\_list στα οποία δεν μπορεί να γίνει απευθείας πρόσβαση σε στοιχεία τους χρησιμοποιώντας ακεραίους αριθμούς για τον προσδιορισμό της θέσης τους. Ειδικά για αυτά τα containers υπάρχει η συνάρτηση μέλος sort που επιτρέπει την ταξινόμησή τους. Στον ακόλουθο κώδικα δημιουργείται μια λίστα με αντικείμενα ορθογωνίων παραλληλογράμμων τα οποία ταξινομούνται με βάση το εμβαδόν τους σε αύξουσα σειρά. Για την ταξινόμηση των αντικειμένων παρουσιάζονται τρεις διαφορετικοί τρόποι που παράγουν το ίδιο αποτέλεσμα.

\lstinputlisting[caption = Ταξινόμηση λίστας με αντικείμενα - α' τρόπος (sort2.cpp)]{lab02/sort2.cpp}

Θα πρέπει να σημειωθεί ότι η δεσμευμένη λέξη this στον κώδικα μιας κλάσης αναφέρεται σε έναν δείκτη προς το ίδιο το αντικείμενο για το οποίο καλούνται οι συναρτήσεις μέλη.

\lstinputlisting[caption = Ταξινόμηση λίστας με αντικείμενα - β' τρόπος (sort3.cpp)]{lab02/sort3.cpp}

\lstinputlisting[caption = Ταξινόμηση λίστας με αντικείμενα - γ' τρόπος (sort4.cpp)]{lab02/sort4.cpp}

\lstinputlisting[style=DOS]{lab02/sort2.out}

Αν αντί για αντικείμενα το container περιέχει εγγραφές τύπου struct Rectangle τότε ένας τρόπος με το οποίο μπορεί να επιτευχθεί η ταξινόμηση των εγγραφών ορθογωνίων σε αύξουσα σειρά εμβαδού είναι ο ακόλουθος.

\lstinputlisting[caption = Ταξινόμηση λίστας με εγγραφές (sort5.cpp)]{lab02/sort5.cpp}

\lstinputlisting[style=DOS]{lab02/sort5.out}

Αντίστοιχα, για να γίνει αναζήτηση ενός στοιχείου σε έναν ταξινομημένο πίνακα μπορούν να χρησιμοποιηθούν συναρτήσεις της STL όπως η συνάρτηση binary\_search, η συνάρτηση lower\_bound και η συνάρτηση upper\_bound. H binary\_search επιστρέφει true αν το στοιχείο υπάρχει στον πίνακα αλλιώς επιστρέφει false. Οι lower\_bound και upper\_bound εντοπίζουν την χαμηλότερη και την υψηλότερη θέση στην οποία μπορεί να εισαχθεί το στοιχείο χωρίς να διαταραχθεί η ταξινομημένη σειρά των υπόλοιπων στοιχείων. Ένα παράδειγμα χρήσης των συναρτήσεων αυτών δίνεται στον ακόλουθο κώδικα.

\lstinputlisting[caption = Αναζήτηση σε ταξινομημένο πίνακα (search1.cpp)]{lab02/search1.cpp}

\lstinputlisting[style=DOS]{lab02/search1.out}

\lstinputlisting[caption = Αναζήτηση σε ταξινομημένο διάνυσμα (search2.cpp)]{lab02/search2.cpp}

\lstinputlisting[style=DOS]{lab02/search2.out}

\section{Lambdas}
Η δυνατότητα lambdas έχει ενσωματωθεί στη C++ από την έκδοση 11 και μετά και επιτρέπει τη συγγραφή ανώνυμων συναρτήσεων στο σημείο που χρειάζονται, διευκολύνοντας με αυτό τον τρόπο τη συγγραφή προγραμμάτων. O όρος lambda ιστορικά έχει προέλθει από τη συναρτησιακή γλώσσα προγραμματισμού LISP. Μια lambda έκφραση στη C++ έχει την ακόλουθη μορφή:

\begin{lstlisting}[style=DOS]
[capture list] (parameter list) -> return type 
{
function body
}
\end{lstlisting}

Συνήθως το τμήμα -> return type παραλείπεται καθώς ο μεταγλωττιστής είναι σε θέση να εκτιμήσει ο ίδιος τον τύπο επιστροφής της συνάρτησης. Στον επόμενο κώδικα παρουσιάζεται μια απλή συνάρτηση lambda η οποία δέχεται δύο double παραμέτρους και επιστρέφει το γινόμενό τους.

\begin{lstlisting}[style=DOS]
cout << "Area = " << [](double x, double y){return x * y;}(3.0, 4.5) << endl;
\end{lstlisting}

Μια lambda συνάρτηση μπορεί να αποθηκευτεί σε μια μεταβλητή και στη συνέχεια να κληθεί μέσω της μεταβλητής αυτής όπως στο ακόλουθο παράδειγμα:

\begin{lstlisting}[style=DOS]
auto area = [](double x, double y)
{
	return x * y;
};
cout << "Area = " << area(3.0, 4.5) << endl;
\end{lstlisting}

Στη συνέχεια παρουσιάζονται διάφορα παραδείγματα lambda συναρτήσεων καθώς και παραδείγματα στα οποία χρησιμοποιούνται lambda συναρτήσεις σε συνδυασμό με τις συναρτήσεις της STL: find\_if, count\_if, sort (σε list και σε vector) και for\_each.

\lstinputlisting[caption = Παραδείγματα με lambdas (lambda1.cpp), multicols=2]{lab02/lambda1.cpp}

\lstinputlisting[style=DOS]{lab02/lambda1.out}

Μια lambda έκφραση μπορεί να έχει πρόσβαση σε μεταβλητές που βρίσκονται στην εμβέλεια που περικλείει την ίδια τη lambda έκφραση. Ειδικότερα, η πρόσβαση (capture) στις εξωτερικές μεταβλητές μπορεί να γίνει είτε με αναφορά (capture by reference), είτε με τιμή (capture by value) είτε να γίνει μικτή πρόσβαση (mixed capture). Το δε συντακτικό που χρησιμοποιείται για να υποδηλώσει το είδος της πρόσβασης είναι:

\begin{itemize}[noitemsep]
\item {[]}: καμία πρόσβαση σε εξωτερικές της lambda συνάρτησης μεταβλητές
\item {[\&]}: πρόσβαση σε όλες τις εξωτερικές μεταβλητές με αναφορά
\item {[=]}: πρόσβαση σε όλες τις εξωτερικές μεταβλητές με τιμή
\item {[a, \&b]}: πρόσβαση στην a με τιμή και πρόσβαση στη b με αναφορά
\end{itemize}

\lstinputlisting[caption = Παραδείγματα με πρόσβαση σε εξωτερικές μεταβλητές σε lambdas (lambda2.cpp),multicols=2	]{lab02/lambda2.cpp}

\lstinputlisting[style=DOS]{lab02/lambda2.out}

\section{Παραδείγματα}
\subsection{Παράδειγμα 1}
Να γράψετε πρόγραμμα που να δημιουργεί πίνακα Α με 1.000 τυχαίες ακέραιες τιμές στο διάστημα [1, 10.000] και πίνακα Β με 100.000 τυχαίες ακέραιες τιμές στο ίδιο διάστημα τιμών. Η παραγωγή των τυχαίων τιμών να γίνει με τη γεννήτρια τυχαίων αριθμών mt19937 και με seed την τιμή 1821. Χρησιμοποιώντας τη συνάρτηση binary\_search της STL να βρεθεί πόσες από τις τιμές του Β υπάρχουν στον πίνακα Α.

\lstinputlisting[caption = Λύση παραδείγματος 1 (lab02\_ex1.cpp)]{lab02/lab02_ex1.cpp}

\lstinputlisting[style=DOS]{lab02/lab02_ex1.out}


\subsection{Παράδειγμα 2}
Η συνάρτηση accumulate() της STL επιτρέπει τον υπολογισμό αθροισμάτων στα στοιχεία ενός container. Δημιουργήστε ένα vector με διάφορες ακέραιες τιμές της επιλογής σας και υπολογίστε το άθροισμα των τιμών με τη χρήση της συνάρτησης accumulate. Επαναλάβετε τη διαδικασία για ένα container τύπου array.

\lstinputlisting[caption = Λύση παραδείγματος 2 (lab02\_ex2.cpp)]{lab02/lab02_ex2.cpp}

\lstinputlisting[style=DOS]{lab02/lab02_ex2.out}

\subsection{Παράδειγμα 3}
Δημιουργήστε ένα vector που να περιέχει ονόματα. Χρησιμοποιώντας τη συνάρτηση next\_permutation() εμφανίστε όλες τις διαφορετικές διατάξεις των ονομάτων που περιέχει το vector.

\lstinputlisting[caption = Λύση παραδείγματος 3 (lab02\_ex3.cpp)]{lab02/lab02_ex3.cpp}

\lstinputlisting[style=DOS]{lab02/lab02_ex3.out}

\subsection{Παράδειγμα 4}
Κατασκευάστε μια συνάρτηση που να επιστρέφει την απόσταση Hamming ανάμεσα σε δύο σειρές χαρακτήρων (η απόσταση Hamming είναι το πλήθος των χαρακτήρων που είναι διαφορετικοί στις ίδιες θέσεις ανάμεσα στις δύο σειρές). Δημιουργήστε ένα διάνυσμα με 100 τυχαίες σειρές μήκους 20 χαρακτήρων η κάθε μια χρησιμοποιώντας μόνο τους χαρακτήρες G,A,T,C. Εμφανίστε το πλήθος από τις σειρές για τις οποίες υπάρχει τουλάχιστον μια άλλη σειρά χαρακτήρων με απόσταση Hamming μικρότερη ή ίση του 10.

\lstinputlisting[caption = Λύση παραδείγματος 4 (lab02\_ex4.cpp), multicols=2]{lab02/lab02_ex4.cpp}

\lstinputlisting[style=DOS]{lab02/lab02_ex4_condensed.out}

\section{Ασκήσεις}
\begin{enumerate}[nolistsep]
\item Γράψτε ένα πρόγραμμα που να δέχεται τιμές από το χρήστη και για κάθε τιμή που θα δίνει ο χρήστης να εμφανίζει όλες τις τιμές που έχουν εισαχθεί μέχρι εκείνο το σημείο ταξινομημένες σε φθίνουσα σειρά. 
\item Γράψτε ένα πρόγραμμα που να γεμίζει ένα διάνυσμα 1.000 θέσεων με τυχαίες πραγματικές τιμές στο διάστημα -100 έως και 100 διασφαλίζοντας ότι γειτονικές τιμές απέχουν το πολύ 10\% η μια από την άλλη. Στη συνέχεια υπολογίστε την επτάδα συνεχόμενων τιμών με το μεγαλύτερο άθροισμα σε όλο το διάνυσμα.
\item Γράψτε ένα πρόγραμμα που να δέχεται τιμές από το χρήστη. Οι θετικές τιμές να εισάγονται σε ένα διάνυσμα v ενώ για κάθε αρνητική τιμή που εισάγεται να αναζητείται η απόλυτη τιμή της στο διάνυσμα v. Καθώς εισάγονται οι τιμές να εμφανίζονται στατιστικά για το πλήθος των τιμών που περιέχει το διάνυσμα, πόσες επιτυχίες και πόσες αποτυχίες αναζήτησης υπήρξαν.
\item Γράψτε ένα πρόγραμμα που να διαβάζει όλες τις λέξεις ενός αρχείου κειμένου και να εμφανίζει πόσες φορές υπάρχει η κάθε λέξη στο κείμενο σε αύξουσα σειρά συχνότητας. Χρησιμοποιήστε ως είσοδο το κείμενο του βιβλίου 1984 του George Orwell \href{http://gutenberg.net.au/ebooks01/0100021.txt}{(http://gutenberg.net.au/ebooks01/0100021.txt)}.
\end{enumerate}

\begin{thebibliography}{9}

\bibitem{geeks4geeks_stl}
\href{http://www.geeksforgeeks.org/cpp-stl-tutorial/}{http://www.geeksforgeeks.org/cpp-stl-tutorial/}.

\bibitem{topcoder_stl1}
\href{https://www.topcoder.com/community/data-science/data-science-tutorials/power-up-c-with-the-standard-template-library-part-1/}{https://www.topcoder.com/community/data-science/data-science-tutorials/power-up-c-with-the-standard-template-library-part-1/}.

\bibitem{topcoder_stl2}
\href{https://www.topcoder.com/community/data-science/data-science-tutorials/power-up-c-with-the-standard-template-library-part-1/}{https://www.topcoder.com/community/data-science/data-science-tutorials/power-up-c-with-the-standard-template-library-part-2/}.

\bibitem{hackerearth_stl}
\href{https://www.hackerearth.com/practice/notes/standard-template-library/}{https://www.hackerearth.com/practice/notes/standard-template-library/}

\end{thebibliography}

