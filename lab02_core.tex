\section{Εισαγωγή}
Στο εργαστήριο αυτό παρουσιάζεται ο μηχανισμός των templates και οι βασικές δυνατότητες της βιβλιοθήκης STL (Standard Template Library) της C++. Τα templates επιτρέπουν την κατασκευή γενικού κώδικα επιτρέποντας την αποτύπωση της λογικής μιας συνάρτησης ανεξάρτητα από τον τύπο των ορισμάτων που δέχεται. Από την άλλη μεριά, η βιβλιοθήκη STL, στην οποία γίνεται εκτεταμένη χρήση των templates παρέχει στον προγραμματιστή έτοιμη λειτουργικότητα για πολλές ενέργειες που συχνά συναντώνται κατά την ανάπτυξη εφαρμογών. Τέλος, γίνεται μια σύντομη αναφορά στην τεχνική ανάπτυξης προγραμμάτων TDD η οποία εξασφαλίζει σε κάποιο βαθμό την ανάπτυξη προγραμμάτων με ορθή λειτουργία εξαναγκάζοντας τους προγραμματιστές να ενσωματώσουν τη δημιουργία ελέγχων στον κώδικα που παράγουν καθημερινά. Επιπλέον υλικό για την STL βρίσκεται στις αναφορές \cite{stamatiadis2017}, \cite{geeks4geeks}, \cite{topcoder}, \cite{hackerearth}.

\section{Templates}
Τα templates είναι ένας μηχανισμός της C++ ο οποίος μπορεί να διευκολύνει τον προγραμματισμό. Η γλώσσα C++ είναι strongly typed και αυτό μπορεί να οδηγήσει στην ανάγκη υλοποίησης διαφορετικών εκδόσεων μιας συνάρτησης έτσι ώστε να υποστηριχθεί η ίδια λογική για διαφορετικούς τύπους δεδομένων. Για παράδειγμα, η εύρεση της ελάχιστης τιμής ανάμεσα σε τρεις τιμές θα έπρεπε να υλοποιηθεί με δύο συναρτήσεις έτσι ώστε να υποστηρίζει τόσο τους ακέραιους όσο και τους πραγματικούς αριθμούς, όπως φαίνεται στον κώδικα που ακολουθεί.

\lstinputlisting[caption=Επανάληψη λογικής κώδικα (lab02\_01.cpp)]{lab02/lab02_01.cpp}

\lstinputlisting[style=DOS]{lab02/lab02_01.out}

Με τη χρήση των templates μπορεί να γραφεί κώδικας που να υποστηρίζει ταυτόχρονα πολλούς τύπους δεδομένων.  Ειδικότερα, χρησιμοποιείται, η δεσμευμένη λέξη template και εντός των συμβόλων < και > τοποθετείται η λίστα των παραμέτρων του template. Ο μεταγλωττιστής αναλαμβάνει να δημιουργήσει όλες τις απαιτούμενες παραλλαγές των συναρτήσεων που θα χρειαστούν στον κώδικα που μεταγλωττίζει.

\lstinputlisting[caption=Χρήση template για αποφυγή επανάληψης λογικής κώδικα (lab02\_02.cpp)]{lab02/lab02_02.cpp}

\lstinputlisting[style=DOS]{lab02/lab02_02.out}

\section{Η βιβλιοθήκη STL}
Η βιβλιοθήκη STL (Standard Template Library) της C++ προσφέρει έτοιμη λειτουργικότητα για πολλά θέματα τα οποία ανακύπτουν συχνά στον προγραμματισμό εφαρμογών. Πρόκειται για μια generic βιβλιοθήκη, δηλαδή κάνει εκτεταμένη χρήση των templates. Βασικά τμήματα της STL είναι οι containers, οι iterators και οι αλγόριθμοι.

\subsection{Containers}
H STL υποστηρίζει έναν αριθμό από containers στους οποίους μπορούν να αποθηκευτούν δεδομένα. Ένα από τα containers είναι το vector. Στον ακόλουθο κώδικα φαίνεται πως η χρήση του vector διευκολύνει τον προγραμματισμό καθώς δεν απαιτούνται εντολές διαχείρισης μνήμης ενώ η δομή είναι δυναμική, δηλαδή το μέγεθος της μπορεί να μεταβάλλεται κατά τη διάρκεια εκτέλεσης του προγράμματος. 

\lstinputlisting[caption=Παράδειγμα με προσθήκη στοιχείων σε vector (lab02\_03.cpp)]{lab02/lab02_03.cpp}

\lstinputlisting[style=DOS]{lab02/lab02_03.out}

Ειδικότερα, τα containers χωρίζονται σε σειριακά (sequence containers) και συσχετιστικά (associate containers). Τα σειριακά containers είναι συλλογές ομοειδών στοιχείων στις οποίες κάθε στοιχείο  έχει συγκεκριμένη θέση μέσω της οποίας μπορούμε να αναφερθούμε σε αυτό. Τα σειριακά containers είναι τα εξής: 
\begin{itemize}[noitemsep]
\item array 
\item deque
\item forward\_list 
\item list 
\item vector
\end{itemize}

Τα συσχετιστικά containers παρουσιάζουν το πλεονέκτημα της γρήγορης προσπέλασης. Συσχετιστικά containers της STL είναι τα εξής: 
\begin{itemize}[noitemsep]
\item set 
\item multiset
\item map
\item multimap
\item unordered\_set
\item unordered\_multiset
\item unordered\_map 
\item unordered\_multimap. 
\end{itemize}

\subsection{Iterators}
Οι iterators αποτελούν γενικεύσεις των δεικτών και επιτρέπουν την πλοήγηση στα στοιχεία ενός container με τέτοιο τρόπο έτσι ώστε να μπορούν να χρησιμοποιηθούν οι ίδιοι αλγόριθμοι σε περισσότερα του ενός containers. Στον ακόλουθο κώδικα παρουσιάζεται το πέρασμα από τα στοιχεία ενός vector με 4  τρόπους. Καθώς το container είναι τύπου vector παρουσιάζεται αρχικά το πέρασμα από τις τιμές του με τη χρήση δεικτοδότησης τύπου πίνακα. Στη συνέχεια χρησιμοποιείται η πρόσβαση στα στοιχεία του container μέσω του range for. Ακολούθως, χρησιμοποιείται ένας iterator για πέρασμα από την αρχή προς το τέλος και μετά ένας reverse\_iterator για πέρασμα από το τέλος προς την αρχή. 

\lstinputlisting[caption = 4 διαφορετικοί τρόποι προσπέλασης των στοιχείων ενός vector (lab02\_04.cpp)]{lab02/lab02_04.cpp}

\lstinputlisting[style=DOS]{lab02/lab02_04.out}

\subsection{Αλγόριθμοι}
H STL διαθέτει πληθώρα αλγορίθμων που μπορούν να εφαρμοστούν σε διάφορα προβλήματα. Για παράδειγμα, προκειμένου να ταξινομηθούν δεδομένα μπορεί να χρησιμοποιηθεί η συνάρτηση sort της STL η οποία υλοποιεί τον αλγόριθμο \href{https://xlinux.nist.gov/dads/HTML/introspectiveSort.html}{Introspective Sort}. Στον ακόλουθο κώδικα πραγματοποιείται η ταξινόμηση ενός στατικού πίνακα και ενός vector.

\lstinputlisting[caption = Ταξινόμηση με τη συνάρτηση sort της STL (lab02\_05.cpp)]{lab02/lab02_05.cpp}

\lstinputlisting[style=DOS]{lab02/lab02_05.out}

Η συνάρτηση sort() εφαρμόζεται σε sequence containers πλην των list και forward\_list στα οποία δεν μπορεί να γίνει απευθείας πρόσβαση σε κάποιο στοιχείο με τη χρήση δείκτη. Ειδικά για αυτά τα containers υπάρχει συνάρτηση μέλος sort που επιτρέπει την ταξινόμησή τους. Στον ακόλουθο κώδικα δημιουργείται μια λίστα με αντικείμενα ορθογώνιων παραλληλογράμμων τα οποία ταξινομούνται με βάση το εμβαδόν τους σε φθίνουσα σειρά. Για την ταξινόμησή τους παρουσιάζονται 4 διαφορετικοί τρόποι.

\lstinputlisting[caption = Ταξινόμηση λίστας με αντικείμενα (lab02\_06.cpp)]{lab02/lab02_06.cpp}

\lstinputlisting[style=DOS]{lab02/lab02_06.out}


Αντίστοιχα, για να γίνει αναζήτηση ενός στοιχείου σε έναν ταξινομημένο πίνακα μπορούν να χρησιμοποιηθούν διάφορες συναρτήσεις της STL όπως η συνάρτηση binary\_search, ή η συνάρτηση upper\_bound. Ένα παράδειγμα χρήσης των συναρτήσεων αυτών δίνεται στον ακόλουθο κώδικα.

\lstinputlisting[caption = Αναζήτηση σε ταξινομημένο πίνακα (lab02\_07.cpp)]{lab02/lab02_07.cpp}

\lstinputlisting[style=DOS]{lab02/lab02_07.out}

\section{TDD=Test Driven Development}
Τα τελευταία χρόνια έχει αναγνωριστεί ως μια αποδοτική τεχνική ανάπτυξης εφαρμογών η οδηγούμενη από ελέγχους ανάπτυξη (Test Driven Development). Αν και το θέμα είναι αρκετά σύνθετο, η βασική ιδέα είναι ότι ο προγραμματιστής πρώτα γράφει κώδικα που ελέγχει αν η ζητούμενη λειτουργικότητα ικανοποιείται και στη συνέχεια προσθέτει τον κώδικα που θα υλοποιεί αυτή τη λειτουργικότητα. Ανά πάσα στιγμή υπάρχει ένα σύνολο από συσσωρευμένους ελέγχους οι οποίοι για κάθε αλλαγή που γίνεται στον κώδικα είναι σε θέση να εκτελεστούν άμεσα και να δώσουν εμπιστοσύνη μέχρι ένα βαθμό στο ότι το υπό κατασκευή ή υπό τροποποίηση λογισμικό λειτουργεί ορθά. Γλώσσες όπως η Java και η Python διαθέτουν εύχρηστες βιβλιοθήκες που υποστηρίζουν την ανάπτυξη TDD (junit και pytest αντίστοιχα). Στην περίπτωση της C++ επίσης υπάρχουν διάφορες βιβλιοθήκες που μπορούν να υποστηρίξουν την ανάπτυξη TDD. Στα πλαίσια του εργαστηρίου θα χρησιμοποιηθεί η βιβλιοθήκη \href{https://github.com/philsquared/Catch}{Catch} για το σκοπό της επίδειξης του TDD.

Στο παράδειγμα που ακολουθεί παρουσιάζεται η υλοποίηση της συνάρτησης παραγοντικό. Το παραγοντικό συμβολίζεται με το θαυμαστικό (!), ορίζεται μόνο για τους μη αρνητικούς ακεραίους αριθμούς και είναι το γινόμενο όλων των θετικών ακεραίων που είναι μικρότεροι ή ίσοι του αριθμού για τον οποίο ζητείται το παραγοντικό. Η πρώτη υλοποίηση είναι λανθασμένη καθώς δεν υπολογίζει σωστά το παραγοντικό του μηδενός που πρέπει να είναι μονάδα. 

\lstinputlisting[caption = Πρώτη έκδοση της συνάρτησης παραγοντικού και έλεγχοι (lab02\_08.cpp)]{lab02/lab02_08.cpp}

\lstinputlisting[style=DOS]{lab02/lab02_08.out}

Η δεύτερη υλοποίηση είναι σωστή. Τα μηνύματα που εμφανίζονται σε κάθε περίπτωση υποδεικνύουν το σημείο στο οποίο βρίσκεται το πρόβλημα και ότι πλέον αυτό λύθηκε.

\lstinputlisting[caption = Δεύτερη έκδοση της συνάρτησης παραγοντικού και έλεγχοι  (lab02\_09.cpp)]{lab02/lab02_09.cpp}

\lstinputlisting[style=DOS]{lab02/lab02_09.out}


\section{Παραδείγματα}
\subsection{Παράδειγμα 1}
Να γράψετε πρόγραμμα που να δημιουργεί πίνακα Α με 1.000 τυχαίες ακέραιες τιμές στο διάστημα [1, 10.000] και πίνακα Β με 100.000 τυχαίες ακέραιες τιμές στο ίδιο διάστημα τιμών. Η παραγωγή των τυχαίων τιμών να γίνει με τη γεννήτρια τυχαίων αριθμών mt19937 και με seed την τιμή 1821. Χρησιμοποιώντας τη συνάρτηση binary\_search της STL να βρεθεί πόσες από τις τιμές του Β υπάρχουν στον πίνακα Α.

\lstinputlisting[caption = Λύση παραδείγματος 1 (lab02\_10.cpp)]{lab02/lab02_10.cpp}

\lstinputlisting[style=DOS]{lab02/lab02_10.out}


\subsection{Παράδειγμα 2}
Η συνάρτηση accumulate() της STL επιτρέπει τον υπολογισμό αθροισμάτων στα στοιχεία ενός container. Δημιουργήστε ένα vector με τυχαίες ακέραιες τιμές και υπολογίστε το άθροισμα των τιμών του με τη χρήση της συνάρτησης accumulate. Επαναλάβετε τη διαδικασία για ένα container τύπου array.

\lstinputlisting[caption = Λύση παραδείγματος 2 (lab02\_11.cpp)]{lab02/lab02_11.cpp}

\lstinputlisting[style=DOS]{lab02/lab02_11.out}

\subsection{Παράδειγμα 3}
Δημιουργήστε ένα vector που να περιέχει ονόματα. Χρησιμοποιώντας τη συνάρτηση next\_permutation() εμφανίστε όλες τις διαφορετικές διατάξεις των ονομάτων που περιέχει το vector.

\lstinputlisting[caption = Λύση παραδείγματος 3 (lab02\_12.cpp)]{lab02/lab02_12.cpp}

\lstinputlisting[style=DOS]{lab02/lab02_12.out}

%\subsection{Παράδειγμα 4}
%
%\section{Ασκήσεις}
%\begin{enumerate}
%\item a
%\item a
%\item a
%\item a
%\end{enumerate}

\begin{thebibliography}{9}
\bibitem{stamatiadis2017}
Σταμάτης Σταματιάδης. Εισαγωγή στη γλώσσα προγραμματισμού C++11. Τμήμα Επιστήμης και Τεχνολογίας Υλικών, Πανεπιστήμιο Κρήτης, 2017, \href{https://www.materials.uoc.gr/el/undergrad/courses/ETY215/notes.pdf}{https://www.materials.uoc.gr/el/undergrad/courses/ETY215/notes.pdf}.

\bibitem{geeks4geeks}
\href{http://www.geeksforgeeks.org/cpp-stl-tutorial/}{http://www.geeksforgeeks.org/cpp-stl-tutorial/}.

\bibitem{topcoder}
\href{https://www.topcoder.com/community/data-science/data-science-tutorials/power-up-c-with-the-standard-template-library-part-1/}{https://www.topcoder.com/community/data-science/data-science-tutorials/power-up-c-with-the-standard-template-library-part-1/}.

\bibitem{hackerearth}
\href{https://www.hackerearth.com/practice/notes/standard-template-library/}{https://www.hackerearth.com/practice/notes/standard-template-library/}


\end{thebibliography}

