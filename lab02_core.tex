\section{Εισαγωγή}
Στο εργαστήριο αυτό παρουσιάζεται ο μηχανισμός των templates, τα lambdas και οι βασικές δυνατότητες της βιβλιοθήκης STL (Standard Template Library) της C++. Τα templates επιτρέπουν την κατασκευή γενικού κώδικα επιτρέποντας την αποτύπωση της λογικής μιας συνάρτησης ανεξάρτητα από τον τύπο των ορισμάτων που δέχεται. Από την άλλη μεριά, η βιβλιοθήκη STL, στην οποία γίνεται εκτεταμένη χρήση των templates παρέχει στον προγραμματιστή έτοιμη λειτουργικότητα για πολλές ενέργειες που συχνά συναντώνται κατά την ανάπτυξη εφαρμογών. Τέλος, γίνεται μια σύντομη αναφορά στην τεχνική ανάπτυξης προγραμμάτων TDD η οποία εξασφαλίζει σε κάποιο βαθμό την ανάπτυξη προγραμμάτων με ορθή λειτουργία εξαναγκάζοντας τους προγραμματιστές να ενσωματώσουν τη δημιουργία ελέγχων στον κώδικα που παράγουν καθημερινά. Επιπλέον υλικό για την STL βρίσκεται στις αναφορές \cite{stamatiadis2017}, \cite{geeks4geeks_stl}, \cite{topcoder_stl1}, \cite{topcoder_stl2}, \cite{hackerearth_stl}. 


\section{Templates}
Τα templates (πρότυπα) είναι ένας μηχανισμός της C++ ο οποίος μπορεί να διευκολύνει τον προγραμματισμό. Η γλώσσα C++ είναι statically typed το οποίο σημαίνει ότι οι τύποι δεδομένων των μεταβλητών και σταθερών ελέγχονται κατά τη μεταγλώττιση. Το γεγονός αυτό μπορεί να οδηγήσει στην ανάγκη υλοποίησης διαφορετικών εκδόσεων μιας συνάρτησης έτσι ώστε να υποστηριχθεί η ίδια λογική για διαφορετικούς τύπους δεδομένων. Για παράδειγμα, η εύρεση της ελάχιστης τιμής ανάμεσα σε τρεις τιμές θα έπρεπε να υλοποιηθεί με δύο συναρτήσεις έτσι ώστε να υποστηρίζει τόσο τους ακέραιους όσο και τους πραγματικούς αριθμούς, όπως φαίνεται στον κώδικα που ακολουθεί.

\lstinputlisting[caption=Επανάληψη λογικής κώδικα (lab02\_01.cpp)]{lab02/lab02_01.cpp}

\lstinputlisting[style=DOS]{lab02/lab02_01.out}

Με τη χρήση των templates μπορεί να γραφεί κώδικας που να υποστηρίζει ταυτόχρονα πολλούς τύπους δεδομένων.  Ειδικότερα, χρησιμοποιείται, η δεσμευμένη λέξη template και εντός των συμβόλων < και > τοποθετείται η λίστα των παραμέτρων του template. Ο μεταγλωττιστής αναλαμβάνει να δημιουργήσει όλες τις απαιτούμενες παραλλαγές των συναρτήσεων που θα χρειαστούν στον κώδικα που μεταγλωττίζει.

\lstinputlisting[caption=Χρήση template για αποφυγή επανάληψης λογικής κώδικα (lab02\_02.cpp)]{lab02/lab02_02.cpp}

\lstinputlisting[style=DOS]{lab02/lab02_02.out}

\section{Lambdas}
Η δυνατότητα lambdas έχει ενσωματωθεί στη C++ από την έκδοση 11 και μετά και επιτρέπει τη συγγραφή ανώνυμων συναρτήσεων στο σημείο που χρειάζονται, διευκολύνοντας με αυτό τον τρόπο τη συγγραφή προγραμμάτων. O όρος lambda ιστορικά έχει προέλθει από τη συναρτησιακή γλώσσα προγραμματισμού LISP. Μια lambda έκφραση στη C++ έχει την ακόλουθη μορφή:

\begin{lstlisting}[style=DOS]
[capture list] (parameter list) -> return type 
{
function body
}
\end{lstlisting}

Συνήθως το τμήμα -> return type παραλείπεται καθώς ο μεταγλωττιστής είναι σε θέση να εκτιμήσει ο ίδιος τον τύπο επιστροφής της συνάρτησης. 

\begin{lstlisting}[style=DOS]
cout << "Area = " << [](double x, int y){return x * y;} << endl;
\end{lstlisting}

Μια lambda συνάρτηση μπορεί να αποθηκευτεί σε μια μεταβλητή και στη συνέχεια να κληθεί μέσω της μεταβλητής αυτής όπως στο ακόλουθο παράδειγμα:

\begin{lstlisting}[style=DOS]
auto area = [](double x, int y)
{
	return x * y;
};
cout << "Area = " << area(3.0, 4.5) << endl;
\end{lstlisting}

Στη συνέχεια παρουσιάζονται παραδείγματα στα οποία χρησιμοποιούνται lambda συναρτήσεις σε συνδυασμό με τις συναρτήσεις της STL: find\_if, count\_if, unique και accumulate.

\begin{lstlisting}[style=DOS]
to be completed
\end{lstlisting}

Μια lambda έκφραση μπορεί να έχει πρόσβαση σε μεταβλητές που βρίσκονται στην εμβέλεια που περικλείει την ίδια τη lambda έκφραση. Ειδικότερα, η πρόσβαση (capture) στις εξωτερικές μεταβλητές μπορεί να γίνει είτε με αναφορά (capture by reference), είτε με τιμή (capture by value) είτε να γίνει μικτή πρόσβαση (mixed capture). Το δε συντακτικό που χρησιμοποιείται για να υποδηλώσει το είδος της πρόσβασης είναι:

\begin{itemize}[noitemsep]
\item {[]}: καμία πρόσβαση σε εξωτερικές της lambda συνάρτησης μεταβλητές
\item {[\&]}: πρόσβαση σε όλες τις εξωτερικές μεταβλητές με αναφορά
\item {[=]}: πρόσβαση σε όλες τις εξωτερικές μεταβλητές με τιμή
\item {[a, \&b]}: πρόσβαση στην a με τιμή και πρόσβαση στην b με αναφορά
\end{itemize}

\begin{lstlisting}[style=DOS]
to be completed
\end{lstlisting}

\section{Η βιβλιοθήκη STL}
Η βιβλιοθήκη STL (Standard Template Library) της C++ προσφέρει έτοιμη λειτουργικότητα για πολλά θέματα τα οποία ανακύπτουν συχνά στον προγραμματισμό εφαρμογών. Πρόκειται για μια generic βιβλιοθήκη, δηλαδή κάνει εκτεταμένη χρήση των templates. Βασικά τμήματα της STL είναι οι containers (υποδοχείς), οι iterators (επαναλήπτες) και οι αλγόριθμοι.

\subsection{Containers}
H STL υποστηρίζει έναν αριθμό από containers στους οποίους μπορούν να αποθηκευτούν δεδομένα. Ένα από τα containers είναι το vector (διάνυσμα). Στον ακόλουθο κώδικα φαίνεται πως η χρήση του vector διευκολύνει τον προγραμματισμό καθώς δεν απαιτούνται εντολές διαχείρισης μνήμης ενώ η δομή είναι δυναμική, δηλαδή το μέγεθος της μπορεί να μεταβάλλεται κατά τη διάρκεια εκτέλεσης του προγράμματος. 

\lstinputlisting[caption=Παράδειγμα με προσθήκη στοιχείων σε vector (lab02\_03.cpp)]{lab02/lab02_03.cpp}

\lstinputlisting[style=DOS]{lab02/lab02_03.out}

Ειδικότερα, τα containers χωρίζονται σε σειριακά (sequence containers) και συσχετιστικά (associative containers). Τα σειριακά containers είναι συλλογές ομοειδών στοιχείων στις οποίες κάθε στοιχείο  έχει συγκεκριμένη θέση μέσω της οποίας μπορούμε να αναφερθούμε σε αυτό. Τα σειριακά containers είναι τα εξής: 
\begin{itemize}[noitemsep]
\item array (πίνακας) 
\item deque (ουρά με δύο άκρα)
\item forward\_list (λίστα διανυόμενη προς τα εμπρός)
\item list (λίστα)
\item vector (διάνυσμα)
\end{itemize}

Τα συσχετιστικά containers παρουσιάζουν το πλεονέκτημα της γρήγορης προσπέλασης. Συσχετιστικά containers της STL είναι τα εξής: 
\begin{itemize}[noitemsep]
\item set (σύνολο)
\item multiset (πολλαπλό σύνολο)
\item map (λεξικό)
\item multimap (πολλαπλό λεξικό)
\item unordered\_set (σύνολο χωρίς σειρά)
\item unordered\_multiset (πολλαπλό σύνολο χωρίς σειρά)
\item unordered\_map (λεξικό χωρίς σειρά)
\item unordered\_multimap. (πολλαπλό λεξικό χωρίς σειρά)
\end{itemize}

Παραδείγματα χρήσης των containers θα παρουσιαστούν στο παρόν και στα επόμενα εργαστήρια.

\subsection{Iterators}
Οι iterators αποτελούν γενικεύσεις των δεικτών και επιτρέπουν την πλοήγηση στα στοιχεία ενός container με τέτοιο τρόπο έτσι ώστε να μπορούν να χρησιμοποιηθούν οι ίδιοι αλγόριθμοι σε περισσότερα του ενός containers. Στον ακόλουθο κώδικα παρουσιάζεται το πέρασμα από τα στοιχεία ενός vector με πέντε τρόπους. Καθώς το container είναι τύπου vector παρουσιάζεται αρχικά το πέρασμα από τις τιμές του με τη χρήση δεικτοδότησης τύπου πίνακα. Στη συνέχεια χρησιμοποιείται η πρόσβαση στα στοιχεία του container μέσω του range for. Ακολούθως, χρησιμοποιείται ένας iterator για πέρασμα από την αρχή προς το τέλος και ένας reverse\_iterator για πέρασμα από το τέλος προς την αρχή. Τέλος χρησιμοποιείται η for\_each σε συνδυασμό με μια lambda συνάρτηση που απλά εμφανίζει τα στοιχεία του vector.

\lstinputlisting[caption = Πέντε διαφορετικοί τρόποι προσπέλασης των στοιχείων ενός vector (lab02\_04.cpp)]{lab02/lab02_04.cpp}

\lstinputlisting[style=DOS]{lab02/lab02_04.out}

\subsection{Αλγόριθμοι}
H STL διαθέτει πληθώρα αλγορίθμων που μπορούν να εφαρμοστούν σε διάφορα προβλήματα. Για παράδειγμα, προκειμένου να ταξινομηθούν δεδομένα μπορεί να χρησιμοποιηθεί η συνάρτηση sort της STL η οποία υλοποιεί τον αλγόριθμο \href{https://xlinux.nist.gov/dads/HTML/introspectiveSort.html}{Introspective Sort}. Στον ακόλουθο κώδικα πραγματοποιείται η ταξινόμηση ενός στατικού πίνακα και ενός vector.

\lstinputlisting[caption = Ταξινόμηση με τη συνάρτηση sort της STL (lab02\_05.cpp)]{lab02/lab02_05.cpp}

\lstinputlisting[style=DOS]{lab02/lab02_05.out}

Η συνάρτηση sort() εφαρμόζεται σε sequence containers πλην των list και forward\_list στα οποία δεν μπορεί να γίνει απευθείας πρόσβαση σε κάποιο στοιχείο με τη χρήση δείκτη. Ειδικά για αυτά τα containers υπάρχει συνάρτηση μέλος sort που επιτρέπει την ταξινόμησή τους. Στον ακόλουθο κώδικα δημιουργείται μια λίστα με αντικείμενα ορθογώνιων παραλληλογράμμων τα οποία ταξινομούνται με βάση το εμβαδόν τους σε φθίνουσα σειρά. Για την ταξινόμησή ορθογωνίων παρουσιάζονται τέσσερις διαφορετικοί τρόποι που παράγουν το ίδιο αποτέλεσμα.

\lstinputlisting[caption = Ταξινόμηση λίστας με αντικείμενα - α' τρόπος (lab02\_06a.cpp)]{lab02/lab02_06a.cpp}

\lstinputlisting[caption = Ταξινόμηση λίστας με αντικείμενα - β' τρόπος (lab02\_06b.cpp)]{lab02/lab02_06b.cpp}

\lstinputlisting[caption = Ταξινόμηση λίστας με αντικείμενα - γ' τρόπος (lab02\_06c.cpp)]{lab02/lab02_06c.cpp}

\lstinputlisting[caption = Ταξινόμηση λίστας με αντικείμενα - δ' τρόπος (lab02\_06d.cpp)]{lab02/lab02_06d.cpp}

\lstinputlisting[style=DOS]{lab02/lab02_06.out}


Αντίστοιχα, για να γίνει αναζήτηση ενός στοιχείου σε έναν ταξινομημένο πίνακα μπορούν να χρησιμοποιηθούν διάφορες συναρτήσεις της STL όπως η συνάρτηση binary\_search, ή η συνάρτηση upper\_bound. Ένα παράδειγμα χρήσης των συναρτήσεων αυτών δίνεται στον ακόλουθο κώδικα.

\lstinputlisting[caption = Αναζήτηση σε ταξινομημένο πίνακα (lab02\_07.cpp)]{lab02/lab02_07.cpp}

\lstinputlisting[style=DOS]{lab02/lab02_07.out}

\section{TDD=Test Driven Development}
Τα τελευταία χρόνια έχει αναγνωριστεί ως μια αποδοτική τεχνική ανάπτυξης εφαρμογών η οδηγούμενη από ελέγχους ανάπτυξη (Test Driven Development). Αν και το θέμα είναι αρκετά σύνθετο, η βασική ιδέα είναι ότι ο προγραμματιστής πρώτα γράφει κώδικα που ελέγχει αν η ζητούμενη λειτουργικότητα ικανοποιείται και στη συνέχεια προσθέτει τον κώδικα που θα υλοποιεί αυτή τη λειτουργικότητα \cite{butunclebob_tdd}. Ανά πάσα στιγμή υπάρχει ένα σύνολο από συσσωρευμένους ελέγχους οι οποίοι για κάθε αλλαγή που γίνεται στον κώδικα είναι σε θέση να εκτελεστούν άμεσα και να δώσουν εμπιστοσύνη μέχρι ένα βαθμό στο ότι το υπό κατασκευή ή υπό τροποποίηση λογισμικό λειτουργεί ορθά. Γλώσσες όπως η Java και η Python διαθέτουν εύχρηστες βιβλιοθήκες που υποστηρίζουν την ανάπτυξη TDD (junit και pytest αντίστοιχα). Στην περίπτωση της C++ επίσης υπάρχουν διάφορες βιβλιοθήκες που μπορούν να υποστηρίξουν την ανάπτυξη TDD. Στα πλαίσια του εργαστηρίου θα χρησιμοποιηθεί η βιβλιοθήκη \href{https://github.com/philsquared/Catch}{Catch} για το σκοπό της επίδειξης του TDD.

Στο παράδειγμα που ακολουθεί παρουσιάζεται η υλοποίηση της συνάρτησης παραγοντικό. Το παραγοντικό συμβολίζεται με το θαυμαστικό (!), ορίζεται μόνο για τους μη αρνητικούς ακεραίους αριθμούς και είναι το γινόμενο όλων των θετικών ακεραίων που είναι μικρότεροι ή ίσοι του αριθμού για τον οποίο ζητείται το παραγοντικό. Η πρώτη υλοποίηση είναι λανθασμένη καθώς δεν υπολογίζει σωστά το παραγοντικό του μηδενός που πρέπει να είναι μονάδα. 

\lstinputlisting[caption = Πρώτη έκδοση της συνάρτησης παραγοντικού και έλεγχοι (lab02\_08.cpp)]{lab02/lab02_08.cpp}

\lstinputlisting[style=DOS]{lab02/lab02_08.out}

Η δεύτερη υλοποίηση είναι σωστή. Τα μηνύματα που εμφανίζονται σε κάθε περίπτωση υποδεικνύουν το σημείο στο οποίο βρίσκεται το πρόβλημα και ότι πλέον αυτό λύθηκε.

\lstinputlisting[caption = Δεύτερη έκδοση της συνάρτησης παραγοντικού και έλεγχοι  (lab02\_09.cpp)]{lab02/lab02_09.cpp}

\lstinputlisting[style=DOS]{lab02/lab02_09.out}


\section{Παραδείγματα}
\subsection{Παράδειγμα 1}
Να γράψετε πρόγραμμα που να δημιουργεί πίνακα Α με 1.000 τυχαίες ακέραιες τιμές στο διάστημα [1, 10.000] και πίνακα Β με 100.000 τυχαίες ακέραιες τιμές στο ίδιο διάστημα τιμών. Η παραγωγή των τυχαίων τιμών να γίνει με τη γεννήτρια τυχαίων αριθμών mt19937 και με seed την τιμή 1821. Χρησιμοποιώντας τη συνάρτηση binary\_search της STL να βρεθεί πόσες από τις τιμές του Β υπάρχουν στον πίνακα Α.

\lstinputlisting[caption = Λύση παραδείγματος 1 (lab02\_10.cpp)]{lab02/lab02_10.cpp}

\lstinputlisting[style=DOS]{lab02/lab02_10.out}


\subsection{Παράδειγμα 2}
Η συνάρτηση accumulate() της STL επιτρέπει τον υπολογισμό αθροισμάτων στα στοιχεία ενός container. Δημιουργήστε ένα vector με διάφορες ακέραιες τιμές της επιλογής σας και υπολογίστε το άθροισμα των τιμών με τη χρήση της συνάρτησης accumulate. Επαναλάβετε τη διαδικασία για ένα container τύπου array.

\lstinputlisting[caption = Λύση παραδείγματος 2 (lab02\_11.cpp)]{lab02/lab02_11.cpp}

\lstinputlisting[style=DOS]{lab02/lab02_11.out}

\subsection{Παράδειγμα 3}
Δημιουργήστε ένα vector που να περιέχει ονόματα. Χρησιμοποιώντας τη συνάρτηση next\_permutation() εμφανίστε όλες τις διαφορετικές διατάξεις των ονομάτων που περιέχει το vector.

\lstinputlisting[caption = Λύση παραδείγματος 3 (lab02\_12.cpp)]{lab02/lab02_12.cpp}

\lstinputlisting[style=DOS]{lab02/lab02_12.out}

\subsection{Παράδειγμα 4}
Κατασκευάστε μια συνάρτηση που να επιστρέφει την απόσταση Hamming ανάμεσα σε δύο σειρές χαρακτήρων που θα δέχεται ως παράμετρο (η απόσταση Hamming είναι το πλήθος των χαρακτήρων που είναι διαφορετικοί στις ίδιες θέσεις ανάμεσα στις δύο σειρές). Δημιουργήστε μια λίστα με 100 τυχαίες σειρές μήκους 100 χρησιμοποιώντας μόνο τους χαρακτήρες G,A,T,C και βρείτε τις αποστάσεις Hamming ανάμεσα σε κάθε πιθανό ζεύγος στοιχείων της λίστας.

\section{Ασκήσεις}
\begin{enumerate}
\item a
 \item a
\item a
\item a
\end{enumerate}

\begin{thebibliography}{9}
\bibitem{stamatiadis2017}
Σταμάτης Σταματιάδης. Εισαγωγή στη γλώσσα προγραμματισμού C++11. Τμήμα Επιστήμης και Τεχνολογίας Υλικών, Πανεπιστήμιο Κρήτης, 2017, \href{https://www.materials.uoc.gr/el/undergrad/courses/ETY215/notes.pdf}{https://www.materials.uoc.gr/el/undergrad/courses/ETY215/notes.pdf}.

\bibitem{geeks4geeks_stl}
\href{http://www.geeksforgeeks.org/cpp-stl-tutorial/}{http://www.geeksforgeeks.org/cpp-stl-tutorial/}.

\bibitem{topcoder_stl1}
\href{https://www.topcoder.com/community/data-science/data-science-tutorials/power-up-c-with-the-standard-template-library-part-1/}{https://www.topcoder.com/community/data-science/data-science-tutorials/power-up-c-with-the-standard-template-library-part-1/}.

\bibitem{topcoder_stl2}
\href{https://www.topcoder.com/community/data-science/data-science-tutorials/power-up-c-with-the-standard-template-library-part-1/}{https://www.topcoder.com/community/data-science/data-science-tutorials/power-up-c-with-the-standard-template-library-part-2/}.

\bibitem{hackerearth_stl}
\href{https://www.hackerearth.com/practice/notes/standard-template-library/}{https://www.hackerearth.com/practice/notes/standard-template-library/}

\bibitem{butunclebob_tdd}
\href{http://butunclebob.com/ArticleS.UncleBob.TheThreeRulesOfTdd}{http://butunclebob.com/ArticleS.UncleBob.TheThreeRulesOfTdd}



\end{thebibliography}

